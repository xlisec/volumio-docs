{"pages":[{"title":"Volumio Documentation","text":"\u00c2\u00a0 Welcome to Volumio's documentation (update August 11th 2018) Volumio is a free and Open Source Linux Distribution, designed and fine-tuned exclusively for music playback. It runs on a variety of devices, typically small and cheap computers like the Raspberry PI, but also on low power PCs, notebooks or thin clients. By flashing (installing) Volumio on any of these platforms, it will become a headless Audiophile Music Player. Headless means that the only way to control it will be with another device - a mobile phone, computer or tablet. This is made possible by Volumio\u00e2\u0080\u0099s UI: a web application that runs on any device with a web browser, that allows an easy and intuitive control of your playback sessions. All communications between the webapp and Volumio will happen through your home network. To learn more about Volumio, see the Discover Page or Technical Overview Page on the Volumio website and the documentation site. This documentation is aimed to help both users and developers, any contribution is welcome to make it better. QUICK LINKS \u00c2\u00a0 USER'S TIPS New to Volumio? Here's our Quick Start Guide See how our OTA (Over the Air) Updater works Volumio can accept Audio stream in multiple ways, see How to Stream Audio to Volumio Volumio features a plugin system to expand its functionalities, see all of them in the Volumio plugins collection forum thread What is an I2S DAC and why its a great solution with Raspberry PI? See it here Looking for changelog? Here it is TROUBLESHOOTING See our FAQ Docs for the most typical issues and their solution Want to get help? This is how you do it Troubles mounting an NFS Share? See how to Mount a NFS Share DEVELOPERS Volumio Backend Github Repository Volumio UI Github Repository Volumio Image Builder Github Repository Volumio uses Websockets to receive commands, see how it works in the WebSocket API Section Learn how to write plugins to add new functionalities to Volumio in the Plugin Section Want to contribute to this guide? See the Contribute to this doc Section Did you know that Volumio has a command line client? Here's how to use the Command Line Client Help by translating Volumio to your language CREDITS This documentation is the result of a commun work from (alphabetical sorting): balbuze (https:\/\/github.com\/balbuze)\u00f0\u009f\u0093\u0096 biva (https:\/\/github.com\/biva)\u00f0\u009f\u0093\u0096 crisp00 (https:\/\/github.com\/crisp00)\u00f0\u009f\u0093\u0096 G\u00c3\u00a9 Koerkamp (https:\/\/github.com\/gkkpch)\u00f0\u009f\u0093\u0096 Ghembs](https:\/\/github.com\/Ghembs)\u00f0\u009f\u0093\u0096 Gianpaolo Macario (https:\/\/github.com\/gmacario)\u00f0\u009f\u0093\u0096 Ian_Sutherland (https:\/\/github.com\/chsims1)\u00f0\u009f\u0093\u0096 JoelTakvorian (https:\/\/github.com\/jotak)\u00f0\u009f\u0093\u0096 luckynrslevin (https:\/\/github.com\/luckynrslevin)\u00f0\u009f\u0093\u0096 macmpi (https:\/\/github.com\/macmpi)\u00f0\u009f\u0093\u0096 Marcus G\u00c3\u00b6tling (https:\/\/github.com\/G\u00c3\u00b6tling)\u00f0\u009f\u0093\u0096 Michelangelo Guarise (https:\/\/github.com\/mikelangeloz)\u00f0\u009f\u0093\u0096 Michiel Fokke (https:\/\/github.com\/foxey)\u00f0\u009f\u0093\u0096 Rachid Groeneveld (https:\/\/github.com\/saiyato)\u00f0\u009f\u0093\u0096 Rob Campbell (https:\/\/github.com\/robcee)\u00f0\u009f\u0093\u0096 sla89 (https:\/\/github.com\/sla89)\u00f0\u009f\u0093\u0096 Volumio (https:\/\/github.com\/Volumio)\u00f0\u009f\u0093\u0096 \u00f0\u009f\u0092\u00bb Xipmix (https:\/\/github.com\/Xipmix)\u00f0\u009f\u0093\u0096 This project follows the all-contributors specification.","tags":"","url":"index.html"},{"title":"Quick Start Guide","text":"Quick start guide DOWNLOAD AND INSTALLATION Please have look here to download a version for your device and instructions to flash it : DOWNLOAD AND FLASH FIRST BOOT Volumio's first boot will take usually longer, up to 6 minutes if you're on a Raspberry PI 1. Therefore, be patient of first boot and wait about 5 minutes before starting to use Volumio. The first time Volumio starts, it will perform some operations: Extend the filesystem to fill completely your SD Card\\ Hard drive Regenerate SSH keys, to make them unique to your device Install some packages and configure the system Generate new thumbnails for the default backgrounds For security reasons, SSH is disabled by default on all versions after 2.199. It can be however enabled very easily. INSTRUCTION HERE NETWORK CONNECTION Volumio works best when its connected to your Network, since it's meant to be used in an headless state: no monitor connected, and controlled via another device (PC, smartphone, tablet etc) To connect Volumio to your network, simply attach an ethernet cable to it before starting it up If no ethernet is available, you can connect to its hotstpot (see below) and connect to your Wi-fi Network. To do so, go to settings -&gt; Network and connect it from there IMPORTANT Do not configure your network manually via SSH, this can lead to issues and malfunctions VOLUMIO HOTSPOT If your device has wireless capabilities (and a supported Wireless card) Volumio will create a Wireless Network called Volumio, the default password is volumio2 The Hotspot mode will allow you to connect to your Wireless Network without the need for a wired connection, just connect to Volumio Hotspot and configure your network on network options Once your Wireless network has been configured, the Hotspot will no longer be visible If, for whatever reason, your configured Wireless network is not available, Volumio will automatically re-enable the Hotspot You can change the Hotspot options in the Network options, such as its name, password and channel (useful if you experience poor Hotspot performances) Once in Hotspot Mode, Volumio can be reached with IP 192.168.211.1 or via http:\/\/volumio.local as usual CONTROL VOLUMIO WITH THE OFFICIAL APPS The most convenient way to control your Volumio system is through the official apps. The advantage is that they will automatically find your Volumio device on your Network. Not to mention that by getting the apps, you will help the project with a little contribution. WEB-UI CONNECTION The UI can be accessed from any device with a browser: Tablets, PC, Mac, Android Phones, iPhones, Smart TVs, Ebook readers etc. Make sure you have the latest versions of their respective browsers. For an optimal experience, Google Chrome is suggested. The UI can be accessed by typing Volumio's IP address in your browser. To find the IP address you can use: ANDROID FING iOS Net Analyzer Chrome mDNS Browser Volumio UI can also be accessed by typing http:\/\/volumio.local, or if you renamed your Volumio device http:\/\/VOLUMIONAME.local . Please note that this function is not available on Android devices, just on Mac and iOs or in Windows (if that does not work, install Bonjour ) WEBUI ON HDMI DISPLAY OR RASPBERRY PI OFFICIAL TOUCH DISPLAY Volumio will show its UI on any attached HDMI display ONLY on X86 Platform. On any other platform this feature is not enabled by default (for performance concerns): once Volumio has finished booting you will see a login prompt, which is absolutely fine. This feature can however be easily achieved on those platforms as well (Raspberry PI, UDOO, Odroid, Pine64 ecc) by installing the &quot;Touchscreen plugin&quot; To install it, navigate to &quot;Plugins&quot; menu entry, click on &quot;Miscellanea&quot; category and install the Touchscreen Plugin. On some devices this might take up to 10 minutes. After the plugin has successfully installed, enable it and you will see the UI on the HDMI connected display (or the official Rasperry PI display, if present) FIRST CONNECTION TO THE WEBUI Once the sytem is on and you connected to it through your network or via the hotspot, you reach Volumio's webUI. The first time, an helper is assisting you to configure Volumio. Don't worry if you missed it, you can still configure it later ! The helper first screen : Choose your LANGUAGE The helper second screen : Choose the NAME for your device The helper third screen : Configure your DAC The helper fourth screen : Configure your NETWORK The helper fifth screen with a configured NAS drive The helper sixth screen : Don't forget to donate ! It will help Volumio to be improved ! Once it is done, you should have a working system,ready to play music! Let's discover it !","tags":"","url":"User_Manual\/Quick_Start_Guide.html"},{"title":"First steps with Volumio","text":"First steps with Volumio Main webUI page Once your system is configured with the helper, you'll see the main page of VOLUMIO Depending on the device you use to connect to Volumio, you'll see the desktop page or the mobile page. Both provide same features, but ergonomic is different to best fit with the use (mobile or desktop) Mobile Main page of Volumio : Desktop Main page of Volumio : Main page description Desktop version 1 - Command buttons Play\/Stop : obvious... Previous : jump to previous track Next : jump to next track 2 - Settings gears Here you'll find all settings for Volumio such as : My Volumio : Here you access to your account My Music : Music sources (nas usb, and album art management) Playback : Output device settings (dac, mixer, resampling) Appearance : To select your language, image background or color Network : Set your wifi, ethernet, dns System : Name your device, have version number and update if available, reset your system, and see credits for Volumio Plugins : To add features to Volumio such Streaming service (Spotify...), gpio management; equalizer, Internet radio ... Alarm : You love to wake up with your favorite music ? It's here! Sleep : You love listening music before sleeping ? It's Here! Shutdown : To stop or reboot your device properly Volumio Shop : A link to the Volumio shop where you'll find compatible and well sounding hardware 3 - Track text information First line : Album name Second line : Track title Third line : Artist name 4 - Volume Settings Inside value : Current volume level External circle : Graphic volume level. Change the volume by moving it. 5 - Timer zone Miscellaneous info about the played track First line : Sample rate \/ bit resolution Second line : Ellapsed time Third line : Total duration Fourth line : Track source 6 - Track management Left : Add to favorite Middle : Add to playlist Right : Go to - Artist\/Album - Tweeter 7 - Album art Display Display album art for the played track or radio if available. 8 - Volume control Left : Lower volume Middle : Mute Right : Higher volume 9 - Multiroom zone Here appear all available Volumio devices on your network. In the picture, the device called VOLUMIO-RPI2 is the current remoted device. To remote an other, clic on it. 10 - Browse page Clicking here, you access to all available music on your system (Nas, Usb disk, radio, Spotify, Youtube etc depending on plugins\/options installed). 11- Playback The current page 12 - Queue Here you access to the current queue with all tracks in it. to be continued....","tags":"","url":"User_Manual\/First_steps_with_Volumio.html"},{"title":"Using tabs","text":"Using tabs Volumio main page provides 3 tabs. Browse Playback Queue We already discovered the Playback tab in the previous page Let's see now the content of the Browse tab and the Queue tab Browse tab Clicking on Browse tab will allow to access all available music sources on your system. 1 - Favorites Favorites : Access your favorites tracks 2 - Playlists Playlists : Access your Playlists 3 - Music Library Music Library : Access your library in files\/folder mode 4 - Artists Artist : Access your library by artist 5 - Albums Albums : Access your library by Albums 6 - Genres Genres : Access your library by genres 7 - Media server Media server : Access your media server if any 8 - Last 100 Last 100 : List the last 100 tracks played 9 - Music Library Radio : Access web radio Adding a radio To add your own radio, click as shown below : and fill the fields : Now your radio is available in My Web Radios 10 - Other Other : Depending on plugins\/options you have installed, you may have other tab such Spotify, Qobuz... Queue tab Clicking on Queue tab will allow to access to the queue of the tracks that are going to be played. 1 - Random Randomize the order tracks are played 2 - Repeat Repeat the track 3 - Save Save the current queue as a playlist. A name is asked for this Playlist 4 - Clear queue Clear the current queue 5 - Remove track Remove track from the queue More features You can change the order of each track by clicking and moving it up or down. to be continued....","tags":"","url":"User_Manual\/Using_tabs.html"},{"title":"System updates","text":"Volumio OTA Updater Volumio features an OTA (Over The Air) updater, meant to allow seamless and reliable way to update to new system versions. This is what the Volumio OTA updater allows: Volumio uses a cloud-based build mechanism for its images, which includes the updater control backbone 1:1 verified updates of new versions, this ensures that new updates are deployed exactly as they are built Differential download: instead of downloading the full firmware, Volumio will download just the differences beetween the current system and the new one. This allows to save up to 90% of download size, resulting also in faster downloads User-data preservation: updating to a new version will keep user data (such as playlists, music files, settings) untouched Ability to reset to factory settings: doing so will revert the system to the first version it was booted to. This will cancel both user data and newer system versions Ability to wipe user-data: doing so will reset all settings to factory defaults, while keeping the last firmware version installed. How to use the OTA updater Verify that your Volumio device is connected to the Internet Click on the cog-wheel in the top right part of the UI Select system Click on &quot;Check Updates&quot; If an update is available, you'll be presented with the new features. Click on &quot;Update Now&quot; System update will start, and depending on the update size it might take up to 20 minutes Once Update has finished, you'll be asked to reboot. Do it The system will now restart, and the new version will be applied Use the system updater to test Beta-Releases Volumio can be updated to Beta Releases via OTA Updater. Beta-releases are test builds of the system with undisclosed functionalities Beta releases are meant to test new functionalities before deploying an update to the entire Volumio userbase Beta releases might not work, or present bugs still to be solved. They are therefore meant for expert users willing to take the risk of losing all their data To receive beta-releases, the system has to be put in &quot;TEST MODE&quot;. To do so, navigate to http:\/\/volumio.local\/dev or http:\/\/yourvolumioip\/dev Once in the \/dev page, click on &quot;TRUE&quot; on &quot;TEST MODE&quot; Section. Your device is now in TEST MODE, and will receive test updates from now on Follow the above instructions to update your system normally, the only difference is that you'll see the test releases in spite of ordinary releases Note You'll see no change when clicking, but it's ok! Disable TEST MODE To disable test mode, navigate to \/dev page and click &quot;FALSE&quot; on &quot;TEST MODE&quot; section. You will now receive only ordinary releases In case you want to revert to old stable release, do a factory reset and then update to latest stable version (this will erase all your data) Considerations over OTA Updater If you're an advanced user and do usually manual settings to the system (e.g. manual changes of config files via SSH, update volumio backend via GIT etc) , we strongly suggest not to USE the OTA updater, since your manual changes will impact the consistency of the updates","tags":"","url":"User_Manual\/System_updates.html"},{"title":"Volume Control and audio quality","text":"Volume Controls and Audio Quality Introduction It's not true that enabling volume control ALWAYS tampers with bit perfect. There are 2 ways to get Volume control: Software mixer: the audio streaming is manipulated to get the desired volume change. This makes the stream not bit perfect, and degrades sound quality Hardware Mixer: its not supported by every DAC, but if the DAC supports this, it will trigger it's array of internal resistors to change the volume. In this mode, you can change the volume while keeping bit perfect and without any audio quality degradation. How to get the best sound and Volume Control Volumio can detect if your DAC supports Hardware mixer, and enable it automatically. If your DAC does not support it, Volumio will allow you to enable software mixer. To change this behaviour you can go to Playback Options -&gt; Volume Settings: Select the Mixer Type: None = No volume control Software = Volume control but loss of Audio Quality Hardware = Best of both worlds, provides ability to change volume without loss of quality","tags":"","url":"User_Manual\/Volume_Control_and_audio_quality.html"},{"title":"Stream audio to volumio","text":"Stream audio to Volumio Volumio usually uses music it finds locally (internal memory, USB disk, ...) or on the network (Spotify, web radio, DLNA server, ...). But it is also able to receive an audio stream directly from devices connected on the local network, such as a smartphone or a computer: in this case, Volumio acts as a renderer, and uses 2 protocols: UPnP\/DLNA or AirPlay. UPnP - DLNA Volumio is a UPnP Media Renderer front-end for MPD (the Music Player Daemon used in Volumio), thanks to upmpdcli This is implemented by default, and nothing needs to be configured on Volumio side Airplay AirPlay is an equivalent protocol to DLNA, but proprietary and developed by Apple. It is used by default by iTunes, and on iPhone, iPad, ... This protocol is now available on other non-Apple sources (see below) This is implemented by default, and nothing needs to be configured on Volumio side Stream from Windows You have several solutions to stream from Windows (all the sound going to your usual speakers will be redirected to a DLNA or AirPlay stream): Stream What You Hear (SWYH), transforming your PC into a DLNA streamer. If it doesn't work, you can also use the &quot;HTTP Live Streaming&quot; function, and indicate the provided URL to Volumio, creating a new Web Radio. TuneBlade, transforming your PC into an Airplay streamer If you want to use this solution in order to stream the audio of a movie you're watching, consider that streaming necessitates a delay: in your video software (for example VLC), use the option to compensate this delay (J and K keys on VLC, usually around 2 seconds delay) From Android In this case too, all the sound going to your usual speakers will be redirected to a DLNA or AirPlay stream Usually, your device must be rooted in order to allow the app to capture the audio from the Android system Several apps are compatible, including AllConnect, AirAudio, AllStream or BubbleUPnP+Xposed. Trouble Shooting Don't hesitate to restart your devices (Windows, Android, Volumio, Wifi router, ...) if you can't connect them","tags":"","url":"User_Manual\/Stream_audio_to_volumio.html"},{"title":"SSH","text":"SSH access on volumio user: volumio password: volumio For security reasons, SSH is disabled by default on all versions after 2.199 (except first boot). It can be however enabled very easily. First method: DEV UI (easy) Navigate to the DEV ui by pointing your browser to VOLUMIOIP\/DEV or volumio.local\/DEV . Find the SSH section, and click enable. From now on your SSH will be permanently enabled. Note : You'll see no change when clicking on the button, but it will be ok. Second method: file (more advanced) Mount your SD card on your computer. Create or copy a file called ssh in \/boot . You can do it right after flashing Volumio, by creating it in the &quot;Boot&quot; partition of your SD Card.","tags":"","url":"User_Manual\/SSH.html"},{"title":"Configure MPD Clients for albumart","text":"When starting the MPod app for the first time: Select &quot;Add player manually&quot; and fill in the following information: Connection - Name: Volumio MPD - Server: ip address or hostname of your volumio device (the hostname defaults to volumio.local) Local Cover Art - URL: volumio.local\/cover-art Local Cover Art - Cover Filename: folder.jpg Leave all other settings at the default. Important note: The cover art URL including the file name is case sensitive (i.e. folder.jpg != Folder.jpg). All your music folders need to use the same casing.","tags":"","url":"User_Manual\/Configure_MPD_Clients_for_albumart.html"},{"title":"Sending logs for troubleshooting","text":"Sending logs for Troubleshooting When your Volumio device does not work as expected, crashes or fails in particular conditions, the only way to understand what goes wrong is usually by looking at logs. So, if you experience such problems, please follow this guide to report your issue to developers. Volumio features an integrated facility to collect logs of your system and publish them in a way to offer developers a clear way to understand what is broken on your system. How to send a bug report Navigate to http:\/\/volumio.local\/dev or http:\/\/yourvolumioip\/dev, where 'yourvolumioip' is the actual IP addess of your device eg. 192.168.1.200 This will open the &quot;DEV&quot; page Scroll until you see a section called &quot;Send logs of bug report&quot; Fill the text field with a clear, but short description of your problem Click on Send Once the logs have been successfully sent, you will see a link like &quot;http:\/\/logs.volumio.org\/xxxxxx&quot; Press the copy button to copy the link to your logs in your clipboard Paste this log wherever you're requesting for help: a forum thread, a githhub issue or a mail If possible, write a very detailed step-to-step guide on how to replicate the problem","tags":"","url":"User_Manual\/Sending_logs_for_troubleshooting.html"},{"title":"Other Customizations","text":"Other Customizations Keyboard layout If you want to temporarlily change the keyboard layout, you can use the following command: sudo loadkeys fr fr should be replaced by the layout you want. If you want to definitively change the keyboard layout, you have to run: sudo apt-get install keyboard-configuration and sudo dpkg-reconfigure keyboard-configuration This may not work on your system: modifications of this documentation are welcome.","tags":"","url":"User_Manual\/Other_Customizations.html"},{"title":"Overview","text":"Volumio is an headless audiophile music player, designed to play music with the highest possible fidelity. Volumio runs on most embedded devices (Raspberry Pi, UDOO, Odroid, Cubieboard, Beaglebone...) and on any ordinary PC (x86). Components Volumio is obtained with 3 main components: Node.js Backend (this repository) This is Volumio core infrastructure. The Volumio2 backend runs on your device and accepts connections from different user interfaces (see later). Angular.JS Frontend This is Volumio's integrated WebUI. It is deployed in \/volumio\/http\/www folder Debian based minimal OS This is Volumio's build script: launch it in a Debian or Ubuntu install, to obtain a complete Volumio Image. Logins Logins user : volumio Password : volumio Root login has been disabled by default for security reasons , however user volumio can become root. Development 101 To maximize efficiency and reduce code regression we're using Git Workflow. For example, to create a new feature you'll: Create a new branch, named after the feature Do your things on the branch Test if everything is fine and we don't have regressions Submit a Pull Request for branch dev All new improvements and developments are meant to be done on the dev branch, once it's declared stable it will be merged to master and deployed to happy Volumio users. Development Guidelines Forum Threads for internal discussion, remember to subscribe topics. Document your work where possible on the Wiki. This is intended to run on Low Power Devices (r-pi). Let's keep code efficient and lightweight. To allow code mantainability, always comment your code properly and update DOCs if needed. Adhere to MVC Best Practices to maximize project quality. Have fun and enjoy what you're doing!","tags":"","url":"Development_How_To\/Overview.html"},{"title":"System Architecture","text":"System Architecture There are two halves of this project on the server side: Volumio OS and the Volumio Core. The Volumio OS is a customized Debian Jessie distribution and ecosystem of software packages which serves as the framework for the system. The Volumio Core is a serverside application (written in Javascript) which runs the music player, music library, and other functions. Architecture Overview Volumio Core has an MVC-like architecture which breaks the player functionality into modules. The modules are organized by function: clients, interfaces, core, controllers, services, and output. Clients The clients represent anything that can open a connection with the Volumio server and send commands. This is code that runs on the client machine, whether it be a PC, tablet, phone, or watch. The Volumio WebUI is one of the possible clients you can use to connect to the Volumio server. It communicates to the server using a standard websocket protocol. And since this is a standard protocol, users may code any other web interface they want, and have it drive Volumio. We also have many users who use MPD clients to drive Volumio. Volumio2 will have a dedicated MPD emulation interface which will be able to interact with your favorite MPD controller. Interface Plugins Which brings us to our next group of modules, the interfaces. Interfaces serve as the intermediaries between the clients and the Volumio core. They translate what are typically text commands into function calls that the core executes. These interface modules are designed to be interchangeable - they offer a set of standard methods that the core can call, and return data in a standard format. We are developing this standard as we go, but the general idea is that users can drop in their own interface modules, which will allow for more interface options than just websocket and MPD emulation. For example, one could write an interface module for hard controls (real knobs and buttons, imagine that!), for local kiosk-style control, etc. Core Modules The core modules run the logic behind the Volumio player. The state machine module contains logic for switching between player states like play, pause, and stop. The play-queue module maintains the list of tracks which are queued up to play. The play queue may contain tracks from any music service. The music library module (more about this later) maintains a database of all the tracks across all services that the user has active. and allows for browsing and searching. The device selector would allow a user to switch between different output sinks - this is yet to be coded, I'm still trying to figure out what this means! The volume module allows for hardware or software level control of the output volume. Finally, the command router module contains no logic, it merely routes function calls to the various other modules. Music Controller Plugins The music controllers are modules which can communicate with individual music services or daemons. Each music service will have its own controller module. The controller can retrieve music information from the service or daemon, and can also send commands to control playback. It is important to note here that each music daemon likely has its own built in play queue and playback status. The Volumio state machine keeps in sync with each of these separate play queues and statuses. This allows the user to interact with Volumio as if it were a single music player, and the Volumio Core controls each of the music services separately in the background. We are currently planning controllers for MPD, Spop, and possibly GMusic. We are also going to add a controller for Libgroove, a nice local audio renderer that can serve as an alternative to MPD. Libgroove uses libav for audio decoding (the same as what VLC uses). Each music controller module will be interchangeable like the user interface modules. Users can write controllers for new music services they would like to add. Music Services The music services are music player daemons or interfaces to online music sources. Some of these will come bundled as part of the Volumio OS, but users can install their own as well. Output Stack The audio output stack is comprised of system-level controllers and other handlers. Under the most basic setup, this only requires ALSA, the system-level interface to your DAC. There is also the option to add SOX into the stack, which would allow for manipulation of audio data. One of the requests we often hear is for multi-room streaming and other output device selection options. Those features would probably go in this output stack somewhere. Currently, I'm still hazy on how this might work, so anyone feel free to jump in with advice! Technologies Used Node.js as the serverside application framework Socket.io for websocket communication Express as the HTTP webserver for the Volumio WebUI Angular as the WebUI framework LevelDB as the persistent database system Kew to run the promise-based asynchronous execution of code (click here to learn what a promise is)","tags":"","url":"Development_How_To\/System_Architecture.html"},{"title":"Set up development environment introduction","text":"Development environment In order to develop new functionalities of Volumio, depending on which part you want to improve, you need to set up a development environment. Volumio is designed to be an highly integrated system. This means that the WebUi is optimized to work along with the custom made Volumio system, and therefore it needs to run in a very tightly controlled environment. IT WON'T WORK on standard Raspbian or other non-volumio OSes. If you want to know what kind of customizations we're using, take a look at the Volumio Builder So, we suggest to have a running Volumio device connected to your local network, while developing on your machine the Backend the UI If you are interested in creating your own images please read on here: Creating Volumio Images","tags":"","url":"Development_How_To\/Set_up_development_environment_introduction.html"},{"title":"Set up development environment for backend","text":"Setting up a development environment for Volumio2 NODE Backend In this scenario, we will develop direclty on the Volumio device, but editing the main files on your PC\\MAC. There are several ways to achieve such result Mount the \/volumio directory of your device to a Folder on your system via sftp (volumio:volumio) Use an IDE that allows remote deplyoment (like Atom or Webstorm which we suggest since its simply awesome!) IMPORTANT: If you want to develop on the latest version, you can simply launch this command to obtain the latest code on master branch: volumio pull If you want to develop or test a certain branch you can use the following command, replacing &lt;branch&gt; with the real name of the branch: volumio pull -b &lt;branch&gt; If you want to develop or test a certain branch of a forked repository you can use the following command, replacing &lt;branch&gt; with the real name of the branch and &lt;repository&gt; with the real name of the repository URL, e.g. something like https:\/\/github.com\/user_who_forked_volumio\/Volumio2.git volumio pull -b &lt;branch&gt; &lt;repository&gt;","tags":"","url":"Development_How_To\/Set_up_development_environment_for_backend.html"},{"title":"Set up development environment for UI","text":"Setting up a development environment for Volumio2 UI Volumio2 UI is an AngularJS based WebAPP. You can develop on it from your PC\\MAC but you need to have a Volumio device on your network. The UI communicates with Volumio's backend via WebSockets using Socket.io Socket.io To set up a development environment on your PC\\MAC do: Install dependencies (only first time) Download and install Node.js ** Volumio2-UI currently requires '''Node.js 6.*'''. 6.9.5 Download and install Bower Download and install Gulp Prepare Volumio2 UI Development folder Clone the UI with: git clone https:\/\/github.com\/volumio\/Volumio2-UI We suggest developing on the development branch, and to push your Pull requests there: cd Volumio2-UI git checkout development Install npm dependencies npm install Install bower dependencies bower install Tell the UI where our Volumio instance is : Now, you can develop on it, while retrieving data from Volumio2 backend (you must have a Volumio2 device on your network and know its IP address). To tell the UI where to find Volumio 2 backend, create a file with the IP of Volumio2 in \/src\/app\/local-config.json The file will look like { &quot;localhost&quot;: &quot;http:\/\/192.168.31.234&quot; } Now, feel free to edit and see live changes on a local browser with dynamically generated UI. To do so: gulp serve --theme=&quot;volumio&quot; Once finished, to deploy on Volumio 2, first build it. if you want production optimization use --env=&quot;production&quot; gulp build --theme=&quot;volumio&quot; --env=&quot;production&quot; And deploy by copying the content of dist directory on Volumio2 device to: \/volumio\/http\/www","tags":"","url":"Development_How_To\/Set_up_development_environment_for_UI.html"},{"title":"Set up development environment for Volumio images","text":"Setting up a development environment for Volumio 2 images We suggest to develop on a debian based environment Install dependencies git squashfs-tools kpartx multistrap qemu-user-static samba debootstrap parted dosfstools qemu binfmt-support qemu-utils Set up development folder clone the build repo on your local folder : git clone https:\/\/github.com\/volumio\/Build build if on Ubuntu, you may need to remove $forceyes from line 989 of \/usr\/sbin\/multistrap cd to \/build and type .\/build.sh -b &lt;architecture&gt; -d &lt;device&gt; -v &lt;version&gt; where switches are : -b &lt;arch&gt; Build a full system image with Multistrap. Options for the target architecture are arm or x86. -d &lt;dev&gt; Create Image for Specific Devices. Supported device names: pi, odroidc1\/2\/xu4\/x2, udoo, cuboxi, bbb, cubietruck, compulab, x86 -l &lt;repo&gt; Create docker layer. Give a Docker Repository name as the argument. -v &lt;vers&gt; Version Example: Build a Raspberry PI image from scratch, version 2.0 : .\/build.sh -b arm -d pi -v 2.0 -l reponame You do not have to build the architecture and the image at the same time. Example: Build the architecture for x86 first and the image version MyVersion in a second step: .\/build.sh -b x86 .\/build.sh -d x86 -v MyVersion","tags":"","url":"Development_How_To\/Set_up_development_environment_for_Volumio_images.html"},{"title":"Updating source files","text":"Update source files When you make changes to any file of Volumio, you can restart the service with killall node or systemctl restart volumio","tags":"","url":"Development_How_To\/Updating_source_files.html"},{"title":"Debugging","text":"Debugging Volumio2 Backend Debugging Volumio 2 with Webstorm from Shaggy Dog on Vimeo. Debugging with system journal You can see all logs, generated both by the system and Volumio with sudo journalctl -f This includes outputs to the console too: console.log('my output') So, ideally, you'll want to: Edit the files from your editor of choice Upload changes to the Volumio device Restart NODE Services See the effects via an SSH connection, with sudo journalctl -f","tags":"","url":"Development_How_To\/Debugging.html"},{"title":"API Overview","text":"Introduction Volumio's main API: websocket The most used API transport in Volumio2 is its Websockets API as it allows almost real time communication with multiple clients. Volumio's WebUI gets and sends data (almost) exclusively via WS. Volumio's WS layer is powered by Socket.io. The WebSocket API interface is located at: https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/app\/plugins\/user_interfaces\/websocket\/index.js Full documentation about Volumio Websocket protocol is provided in the next section Volumio's REST API Alternatively, a small subset of system calls are available trough RESTful APIs, in json format. They are available in the REST API section","tags":"","url":"API\/API_Overview.html"},{"title":"WebSocket APIs","text":"Introduction The most used API transport in Volumio2 is its Websockets API as it allows almost real time communication with multiple clients. Volumio's WebUI gets and sends data (almost) exclusively via WS. Volumio's WS layer is powered by Socket.io. The WebSocket API interface is located at: https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/app\/plugins\/user_interfaces\/websocket\/index.js Scenarios Websocket communication in Volumio is identifiable in the most basic server\/client architecture. The Server is Volumio itself (aka the host where Volumio is running), the client can be one or more WebUIs or other consumers (Apps and so on). In some cases, Volumio hosts can also act as client, to communicate with other hosts on the same network. Events Socket.io allows to invoke events triggered by other events, emit and receive communications (on its most basic implementation). As an example, defining which event should be invoked on a client connection looks like: self.libSocketIO.on('connection', function (connWebSocket) { \/\/ use connWebSocket here }); This way, we can define what event should be triggered when a particular message is received: connWebSocket.on('bringmepizza', function () { givehimpizza(); }); Typically, every message we send or receive to Volumio's Backend will have this structure: io.emit('message','data'); Where message can be for example &quot;play&quot; and data can be the song number. A good policy for sending data on emits is to configure them as objects: they're easier to parse and easily extendable. So our message can be: io.emit('addToPlaylist', {&quot;name&quot;: &quot;Music&quot;, &quot;service&quot;: &quot;mpd&quot;, &quot;uri&quot;: &quot;music-library\/...&quot;}); Events Documentation Basic Playback Commands **Play:** play **Pause:** pause **Stop:** stop **Previous:** prev **Next:** next **Seek** seek N (N is the time in seconds that the playback will keep) **Random** setRandom({&quot;value&quot;:true|false}) **repeat** setRepeat({&quot;value&quot;:true|false}) Get Player State getState Reply: pushState { &quot;status&quot;: &quot;stop&quot;, &quot;position&quot;: 0, &quot;title&quot;: &quot;Matilda Mother&quot;, &quot;artist&quot;: &quot;Pink Floyd&quot;, &quot;album&quot;: &quot;The Piper At The Gates Of Dawn&quot;, &quot;albumart&quot;: &quot;\/albumart?web=Pink%20Floyd\/The%20Piper%20At%20The%20Gates%20Of%20Dawn\/extralarge&amp;path=%2FNAS%2FHi_Res_Music%2FPINK%20FLOYD%20Discovery%20Studio%20Album%20Box%20Set%20(2011)%20FLAC%2F1967%20The%20Piper%20At%20The%20Gates%20Of%20Dawn&quot;, &quot;uri&quot;: &quot;mnt\/NAS\/Hi_Res_Music\/PINK FLOYD Discovery Studio Album Box Set (2011) FLAC\/1967 The Piper At The Gates Of Dawn\/03 - Matilda Mother.flac&quot;, &quot;trackType&quot;: &quot;flac&quot;, &quot;seek&quot;: 0, &quot;duration&quot;: 189, &quot;random&quot;: false, &quot;repeat&quot;: false, &quot;repeatSingle&quot;: false, &quot;volume&quot;: 39, &quot;mute&quot;: false, &quot;stream&quot;: false, &quot;updatedb&quot;: false, &quot;volatile&quot;: false, &quot;service&quot;: &quot;mpd&quot; } Where status is the status of the player position is the position in the play queue of current playing track (if any) title is the item's title artist is the item's artist album is the item's album albumart the URL of AlbumArt (via last.fm APIs) uri it's the track's unique uri trackType The track's type: e.g. mp3, flac, spotify etc seek is the item's current elapsed time duration is the item's duration, if any random if true, random mode is enabled repeat if true, repeat mode is enabled repeatSingle if true, repeat single mode is enabled (song is replayed in a cycle) volume current Volume mute if true, Volumio is muted stream if true, Volumio is playing a stream (webradio) updatedb if true, Volumio is updating its internal music database volatile if true, Volumio is in Volatile mode (analog input) samplerate current samplerate bitdepth bitdepth channels mono or stereo service current playback service (mpd, spop...) Search search {value:'query'} Where query is my search query. (note that for using live search, DO NOT send queries with less than 3 characters, they will dramatically slow search operations). Volume Set to percentage, raise or lower, mute or unmute. Message: volume Data: numeric value between 0 and 100 mute umute + - Example io.emit('volume', 90); io.emit('volume', '+'); Mute Message: mute Example io.emit('mute', ''); Unmute Message: unmute Example io.emit('unmute', ''); Multiroom getMultiRoomDevices Retrieves all devices connected to the same network. Input: None Output (through pushMultiRoomDevices socket.io event): { &quot;misc&quot;: {&quot;debug&quot;: true}, &quot;list&quot;: [ { &quot;id&quot;:&quot;uuid&quot;, &quot;host&quot;:&quot;&quot;, &quot;name&quot;:&quot;&quot;, &quot;isSelf&quot;:true|false, &quot;state&quot;: { &quot;status&quot;: &quot;&quot;, &quot;volume&quot;: 0, &quot;mute&quot;: true|false, &quot;artist&quot;: &quot;&quot;, &quot;track&quot;: &quot;&quot; }, { &quot;id&quot;:&quot;uuid&quot;, &quot;host&quot;:&quot;&quot;, &quot;name&quot;:&quot;&quot;, &quot;isSelf&quot;:true|false, &quot;state&quot;: { &quot;status&quot;: &quot;&quot;, &quot;volume&quot;: 0, &quot;mute&quot;: true|false, &quot;artist&quot;: &quot;&quot;, &quot;track&quot;: &quot;&quot; } ] } Browse Music Library browseLibrary objBrowseParameters Where objBrowseParameters are the parameters we want to dig into. This returns the desired level in the music library along with navigation and pagination informations. { navigation: { prev: { uri: '' }, list: [ {service: 'mpd', type: 'song', title: 'track a', artist: 'artist a', album: 'album', icon: 'music' uri: 'uri'}, {type: 'folder', title: 'folder a', icon: 'folder-open-o' uri: 'uri'}, {type: 'folder', title: 'folder b', albumart: '\/\/ip\/image' uri: 'uri2'}, {type: 'playlist', title: 'playlist', icon: 'bars' uri: 'uri4'} ] } } The browsable items can be; Track Folder (can also be a category) Playlist Their parameters are: Type: track, folder, category Title: If this is a song: title, if folder or category is their name. Artist and Album: used only if the type is song Icon or image: Select the icon to display (naming of Font-Awesome ) , or image (URL served by Volumio Backend or external service) Uri: Uri Get Music Library Available filters getBrowseFilters This returns available filters (browse by) {name:'Genres by Name', index: 'index:Genres by Name'}, {name:'Artists by Name', index: 'index:Artists by Name'}, {name:'Albums by Name', index: 'index:Albums by Name'}, {name:'Albums by Artist', index: 'index:Albums by Artist'}, {name:'Tracks by Name', index: 'index:Tracks by Name'} Get Music Sources getBrowseSources This returns a list of available Music Sources {name:'USB', uri: 'usb'}, {name:'NAS', uri: 'nas'}, {name:'Web Radio', uri: 'web-radio'}, {name:'Spotify', uri: 'spotify'} Custom Browse Source This can be useful when creating a new plugin, to inject custom views in the browse sources panel, along with top-level custom actions. { &quot;name&quot;: &quot;Custom Source&quot;, &quot;pluginName&quot;: &quot;streaming_controller&quot;, &quot;pluginType&quot;: &quot;music_service&quot;, &quot;uri&quot;: &quot;stream&quot;, &quot;info&quot;: &quot;Additional info&quot;, &quot;menuItems&quot;: [ { &quot;name&quot;: &quot;play&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;launchStream&quot;, &quot;data&quot;: &quot;&quot; } } }, { &quot;name&quot;: &quot;rip&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;updateStream&quot;, &quot;data&quot;: &quot;&quot; } } }, { &quot;name&quot;: &quot;eject&quot;, &quot;socketCall&quot;: { &quot;emit&quot;: &quot;callMethod&quot;, &quot;payload&quot;: { &quot;endpoint&quot;: &quot;music_service\/streaming_controller&quot;, &quot;method&quot;: &quot;refreshStream&quot;, &quot;data&quot;: &quot;&quot; } } } ]} Play Queue Controls Get Current Play Queue GetQueue Response: pushQueue [ { uri: 'http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=830692', title: 'ANTENA1 - 94 7 FM', service: 'webradio', name: 'ANTENA1 - 94 7 FM', albumart: '\/albumart', samplerate: '', bitdepth: '', channels: 0, trackType: 'webradio' }, { uri: 'mnt\/NAS\/FLAC\/Muse - Black Holes And Revelations - FLAC - HellraiserRG\/02 - Starlight.flac', service: 'mpd', name: 'Starlight', artist: 'Muse', album: 'Black Holes And Revelations', type: 'track', tracknumber: 0, albumart: '\/albumart?web=Muse\/Black%20Holes%20And%20Revelations\/extralarge&amp;path=%2FNAS%2FFLAC%2FMuse%20-%20Black%20Holes%20And%20Revelations%20-%20FLAC%20-%20HellraiserRG', duration: 240, samplerate: '44.1 KHz', bitdepth: '16 bit', trackType: 'flac', channels: 2 }] Remove Item from queue removeFromQueue N where N is the track number in the queue, 0 for the first, 9 for the tenth and so on Response: pushQueue Add Item to Queue addToQueue {'uri:uri'} where uri is the uri of the item we want to add Move a queue item moveQueue {from:N,to:N2} Where N is the track number we want to move, and N2 is its new position If we want to add an individual track from a .cue file: addPlayCue {uri:'uriofsong',number:3} Favourites handling Available functionality: addToFavourites removeFromFavourites addToFavourites This method adds a song to the favourites Input: { &quot;uri&quot;:&quot;my_uri\/...&quot;, &quot;title&quot;:&quot;my song&quot;, &quot;service&quot;:&quot;my_service&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false removeFromFavourites This method removes all occurrences of a song from the favourites Input: { &quot;uri&quot;:&quot;my_uri\/...&quot;, &quot;service&quot;:&quot;my_service&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false Playlist handling Available functionality: createPlaylist deletePlaylist listPlaylist addToPlaylist removeFromPlaylist playPlaylist enqueue createPlaylist This method creates a new playlist Input: { &quot;name&quot;:&quot;myplaylist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false deletePlaylist This method deletes a playlist Input: { &quot;name&quot;:&quot;myplaylist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false listPlaylist This method lists all playlists in the system Input: None Output (through event pushListPlaylist): [ &quot;playlistA&quot;, &quot;playlistB&quot;, ... ] The reason field is set only if success is false addToPlaylist This method adds a song to an existing playlist Input: { &quot;name&quot;:&quot;my playlist&quot;, &quot;service&quot;:&quot;mpd&quot;, &quot;uri&quot;:&quot;USB\/...&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false removeFromPlaylist This method removes all occurrences of a song from an existing playlist Input: { &quot;name&quot;:&quot;my playlist&quot;, &quot;uri&quot;:&quot;USB\/...&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false playPlaylist This method clears the queue, adds the playlist and play Input: { &quot;name&quot;:&quot;my playlist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false enqueue This method enqueue all songs of a playlist Input: { &quot;name&quot;:&quot;my playlist&quot; } Output: { &quot;success&quot;:true|false &quot;reason&quot;:&quot;failure details&quot; } The reason field is set only if success is false CallMethod on Plugin Each method of a plugin can be execute through a websocket call. As of now there's no ACL or any security feature but thi s will change in the future. To execute a method the following socket.io command shall be issued: callMethod The payload shall be a json with the following structure: { &quot;endpoint&quot;:&quot;category\/name&quot;, &quot;method&quot;:&quot;methodName&quot;, &quot;data&quot;: {} } where: endpoint is a string used to target the plugin. Its structure is a linux path like string containing the plugin category, a slash and the plugin name. An example: endpoint:'music_service\/spop'. method is a string containing the name of the method to be executed. data is a complex value (can be a string or a Json) and is passed as is to the method. IMPORTANT: There should be no &quot;-&quot; in this call, due to FE parsing method (it converts \/ to -). So plugins and functions should not contain &quot;-&quot;. Once the method returns, the result is pushed back to the client with the event 'pushMethod'. Miscellaneous Sleep &amp; Alarm Clock getSleep Triggers : pushSleep {enabled:true|false, time:hh:mm:} To set sleep mode: setSleep {enabled:true|false, time:hh:mm:} getAlarms Triggers: pushAlarms {[{id:1,enabled:true, time:hh:mm, playlist:uriplaylist},{id:2,enabled:true, time:hh:mm, playlist:uriplaylist}]} To add a new alarm: addAlarm {time:hh:mm, playlist:uriplaylist} When a new Playlist gets added, the Values enabled:true and id (as progressive numbering) are added by default by the Backend. To edit an alarm: setAlarm {id:1,enabled:true, time:hh:mm, playlist:uriplaylist} Those values will replace the values of the correspondent playlist id. To remove an alarm: removeAlarm {id:3}","tags":"","url":"API\/WebSocket_APIs.html"},{"title":"UI Configuration Pages","text":"Design Principles The main idea is to provide a mechanism to describe the configuration section of the UI and the configuration of plugins that is flexible and not bound to code. To reach this the whole hs to be described with an higher level language. Plugin\\Core component Configuration is composed of different parts: Configuration File Configurations reside on single .json files, pertaining to a core component or a specific plugin. Every core component that needs a configuration file (example: network controller, Network Mount Controller, Playback Settings) will have their json specific file into \/app\/config . If a controller has its own folder, the json config file will be placed in the same controller folder, along with the index.js file. The configuration will be handled by Convict and it will look this way: Each item is described as follows: &quot;KEY&quot;:{ &quot;value&quot;:&quot;VALUE&quot;, &quot;type&quot;:&quot;[boolean|int|string|password|ipaddress|page|section|select]&quot;, &quot;label&quot;:&quot;Blah blah&quot; } where: KEY [MANDATORY] identifies the item. VALUE [OPTINAL] this attribute contains the current item value. Its format depends on the type. For example a boolean type will contains true or false while a string type can contain any string. TYPE [MANDATORY] this attribute describes the data type. As of now the above values are supported. More can (and will) come in the future. DOC [MANDATORY] This attribute contains the label associated to the item, in the locale specified by the caller (Example for Wired Network Config File) var wirednetworkconf = convict({ dhcp: { doc: &quot;DHCP Configuration&quot;, format: [&quot;dhcp&quot;, &quot;static&quot;], default: &quot;dhcp&quot;, value: &quot;dhcp&quot; }, ip: { doc: &quot;Static IP Address &quot;, format: &quot;ipaddress&quot;, default: &quot;null&quot;, value: &quot;IP_ADDRESS&quot;, }, netmask: { doc: &quot;Netmask&quot;, format: &quot;ipaddress&quot;, default: 255.255.255.0, value: &quot;255.255.255.0&quot; }, gateway: { doc: &quot;Gateway&quot;, format: &quot;ipaddress&quot;, default: &quot;null&quot;, value: &quot; &quot; } }); Another example is SPOP's config file , the spotify daemon: var spopconf = convict({ spotify_username: { doc: &quot;Spotify Username&quot;, format: [&quot;*&quot;], default: &quot;null&quot;, env: &quot; &quot; }, spotify_username: { doc: &quot;Spotify Username&quot;, format: &quot;*&quot;, default: &quot;null&quot;, env: &quot; &quot;, }, high_bitrate: { doc: &quot;Prefer High Bitrate Streams&quot;, format: [&quot;true&quot;, &quot;false&quot;], default: &quot;true&quot;, env: &quot;true&quot; }, enabled: { doc: &quot;Enable Spotify Service&quot;, format: &quot;*&quot;, default: &quot;false&quot;, env: &quot;false&quot; }, }); Index File Each configuration will have in its parent index.js (the actual core component\\plugin file), among the others, methods that describes: Required Start If the Component\\ plugin needs a daemon or service to be up and running, it's invoke function must be present. start Required Re-Start If the Component\\ plugin needs a daemon or service to be restarted when its configuration changes, it's restart function must be present. restart Install A function that installs the required (if any) external packages. This can be a shell script, an apt package. It must perform the installation and report a Success message or an error message, with indication of what happened. A method for specific component function Example: if this is a sources plugin, which services are exposed and how to retrieve them. TO BE FURTHER DISCUSSED Display Section This will be invoked by the front end when the pertaining configuration page is to be shown. This function will appropriately parse and serve via the Socket Interface a &quot;layout&quot; of the pertaining configuration page. We'll use a standardized way to provide the UI with predefined layout elements and DOMs, that will be consistent across the whole Volumio frontend system. DOM COMPONENTS Initially we'll have only 2 DOM: Section: This will be used as containers for specific configurations inclusion. Page Title: speaks for itself Example: Network Configuration Page (name), will contain 2 sections: Wired And Wireless. ELEMENTS The elements are used just to manipulate the configuration in the most appropriate way. And their number will be finite. We're taking standard bootstrap naming and examples as reference, even if look and feel will be customized . Select Input (text or string) Save\\Discard Bar Progress Bar Selector Checkbox Radio Button Those configurations fields can be nested, and with DOM style element included, will represent a &quot;skeleton&quot; for the UI frontend to wrap and build accordingly. As a mere example, let's see how Wireless Configuration Page will look like (this is the emitted object via socket.io to the backend) : &quot;networkpage&quot;:{ &quot;title&quot;:&quot;Network Settings&quot; &quot;section&quot;:{ &quot;title&quot;:&quot;Wired Networking&quot;, &quot;label&quot;:&quot;Network configuration&quot;, &quot;children&quot;:{ &quot;wifi&quot;:{ &quot;value&quot;:&quot;true&quot;, &quot;type&quot;:&quot;boolean&quot;, &quot;label&quot;:&quot;Enable Wifi&quot; } } }, &quot;sub_page_b&quot;:{ &quot;type&quot;:&quot;page&quot;, &quot;label&quot;:&quot;System configuration&quot; &quot;children&quot;:{} }, } } ##Linking items in a hierarchy Items can be linked in a tree hierarchy. To do this the attribute children is specified. Its value is an object containig subitems. Below an example: &quot;main&quot;:{ &quot;type&quot;:&quot;page&quot;, &quot;label&quot;:&quot;Network Configuration&quot; &quot;children&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Wired Network&quot;, &quot;children&quot;:{ &quot;dhcp&quot;:{ &quot;type&quot;:&quot;select&quot;, &quot;label&quot;:&quot;DHCP Network Settings&quot;, &quot;current_value&quot;:&quot;true&quot;, &quot;options&quot;:[{true: Automatic (DHCP)},{false:Static}], }, &quot;children&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Static IP Configuration&quot;, &quot;visibleif&quot; &quot;dhcp:false&quot; \/\/show if dhcp is set to false :{ &quot;IP&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;IP&quot; }, &quot;netmask&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;Netmask&quot; }, &quot;gateway&quot;:{ &quot;type&quot;:&quot;text_box&quot;, &quot;value&quot;:&quot; &quot;, &quot;format&quot;:ipaddress, &quot;label&quot;:&quot;Gateway&quot; }, } } }, &quot;wireless_section&quot;:{ &quot;type&quot;:&quot;section&quot;, &quot;label&quot;:&quot;Wireless Network&quot;, }, } }","tags":"","url":"API\/UI_Configuration_Pages.html"},{"title":"REST API","text":"Playback commands All API calls will look like: volumio.local\/api\/v1\/commands\/?cmd= example: volumio.local\/api\/v1\/commands\/?cmd=play Available commands: Play volumio.local\/api\/v1\/commands\/?cmd=play&amp;N=2 where N is optional and is the ordinal number of the track in the queue you wish to start to play from. The above call will play the third track in the queue. Stop volumio.local\/api\/v1\/commands\/?cmd=stop Pause volumio.local\/api\/v1\/commands\/?cmd=pause Previous volumio.local\/api\/v1\/commands\/?cmd=prev Next volumio.local\/api\/v1\/commands\/?cmd=next Volume volumio.local\/api\/v1\/commands\/?cmd=volume&amp;volume=80 where volume can be: mute, unmute, plus, minus (plus and minus will increase\\decrease as per parameter one click volume steps) Music Library Get the current state of the player volumio.local\/api\/v1\/getstate Response {&quot;status&quot;:&quot;play&quot;,&quot;position&quot;:0,&quot;title&quot;:&quot;La guerra \u00c3\u00a8 finita&quot;,&quot;artist&quot;:&quot;Baustelle&quot;,&quot;album&quot;:&quot;La malavita&quot;,&quot;albumart&quot;:&quot;\/albumart?web=Baustelle\/La%20malavita\/extralarge&amp;path=%2FNAS%2FMusic%2FBaustelle%20-%20La%20Malavita&quot;,&quot;uri&quot;:&quot;mnt\/NAS\/Music\/Baustelle - La Malavita\/02 la guerra \u00c3\u00a8 finita.mp3&quot;,&quot;trackType&quot;:&quot;mp3&quot;,&quot;seek&quot;:4224,&quot;duration&quot;:262,&quot;samplerate&quot;:&quot;44.1 KHz&quot;,&quot;bitdepth&quot;:&quot;24 bit&quot;,&quot;channels&quot;:2,&quot;random&quot;:null,&quot;repeat&quot;:null,&quot;repeatSingle&quot;:false,&quot;consume&quot;:false,&quot;volume&quot;:41,&quot;mute&quot;:false,&quot;stream&quot;:&quot;mp3&quot;,&quot;updatedb&quot;:false,&quot;volatile&quot;:false,&quot;service&quot;:&quot;mpd&quot;} Clear the queue volumio.local\/api\/v1\/commands\/?cmd=clearQueue List Playlists volumio.local\/api\/v1\/listplaylists Play a Playlist volumio.local\/api\/v1\/commands\/?cmd=playplaylist&amp;name=Rock where name is the name of the playlist to play Backup This is the generic command to retrieve a json with the playlist selected in type. Allowed types are: &quot;playlist&quot; replies with custom playlists, sorted by their names. &quot;favourites&quot; replies with the playlist of favorites songs. &quot;radio-favourites&quot; replies with the playlist of favorites radios. &quot;my-web-radio&quot; replies with the playlist of custom radios. volumio.local\/api\/v1\/backup\/playlists\/:type Reply: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=893796&quot;, &quot;title&quot;: &quot;Dance Wave!&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=832669&quot;, &quot;title&quot;: &quot;Radio Sobsomoy&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=862132&quot;, &quot;title&quot;: &quot;ANTENA1 - 94 7 FM&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=344030&quot;, &quot;title&quot;: &quot;U1 Tirol&quot;, &quot;icon&quot;: &quot;fa-microphone&quot; } ] This is an example of volumio.local\/api\/v1\/backup\/playlists\/radio-favourites. This is the generic command to retrieve a json with the configurations of every plugin, with their status, sorted by category. volumio.local\/api\/v1\/backup\/config\/ Reply: [ { &quot;cName&quot;: &quot;system_controller&quot;, &quot;plugConf&quot;: [ { &quot;name&quot;: &quot;updater_comm&quot;, &quot;status&quot;: true, &quot;config&quot;: &quot;&quot; }, { &quot;name&quot;: &quot;network&quot;, &quot;status&quot;: true, &quot;config&quot;: { &quot;dhcp&quot;: { &quot;value&quot;: true, &quot;type&quot;: &quot;boolean&quot; }, &quot;ethip&quot;: { &quot;value&quot;: &quot;127.0.0.1&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;ethnetmask&quot;: { &quot;value&quot;: &quot;255.255.255.0&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;ethgateway&quot;: { &quot;value&quot;: &quot;0.0.0.0&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;wlanssid&quot;: { &quot;value&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; }, &quot;wlanpass&quot;: { &quot;value&quot;: &quot;&quot;, &quot;type&quot;: &quot;string&quot; } } }, { &quot;name&quot;: &quot;networkfs&quot;, &quot;status&quot;: true, &quot;config&quot;: { &quot;NasMounts&quot;: { &quot;53b83b5a-dccf-4d2f-800e-96fdc5dc4eb1&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;FLAC&quot; }, &quot;ip&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;DISKSTATION&quot; }, &quot;path&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;FLAC&quot; }, &quot;fstype&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;cifs&quot; }, &quot;user&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;password&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;options&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; } } } } } This is the generic command to restore a playlist: volumio.local\/api\/v1\/restore\/playlists You have to specify, as POST fields: type: playlist songs radios myRadios path: favourites radio-favourites my-web-radio data Type is the kind of data you're sending, path is required for default playlists, to name the correspondent file (since for custom playlists the file will be named after the name found in data), data is a json containing informations properly formatted. This is the generic command to restore configuration files: volumio.local\/api\/v1\/restore\/config You have to specify a POST field named config, that has to contain an array of JSON object with plugins and correspondent configurations, sorted by category.","tags":"","url":"API\/REST_API.html"},{"title":"Command Line Client","text":"Volumio has a command line client which can be invoked with the command volumio By invoking it, you'll see the help output with a list of the available commands: Usage : volumio &lt;argument1&gt; &lt;argument2&gt; [[PLAYBACK STATUS]] status Gives Playback status information volume Gives Current Volume Information volume &lt;desired volume&gt; Sets Volume at desired level 0-100 volume mute Mutes volume unmute Unmutes volume plus Increases Volume of one step volume minus Decreases Volume of one step seek plus Forwards 10 seconds in the song seek minus Backwards 10 seconds in the song seek &lt;seconds&gt; Plays song from selected time repeat Toggles repetition of queue random Toggles randomization of queue [[PLAYBACK CONTROL]] play Play pause Pause next Next track previous Previous track stop Stop clear Clear current queue [[VOLUMIO SERVICE CONTROL]] vstart Starts Volumio Service vstop Stops Volumio Service vrestart Restarts Volumio Service [[VOLUMIO DEVELOPMENT]] pull Pulls latest github status on master from https:\/\/github.com\/volumio\/Volumio2.git pull -b &lt;branch&gt; Pulls branch &lt;branch&gt; from https:\/\/github.com\/volumio\/Volumio2.git pull -b &lt;branch&gt; &lt;repository&gt; Pulls branch &lt;branch&gt; from git repository &lt;repository&gt; dev Start Volumio in develpment mode, with Nodemon and Remote Debugger kernelsource Gets Current Kernel source (Raspberry PI only) plugin init Creates a new plugin plugin refresh updates plugin in the system plugin package compresses the plugin plugin publish publishes the plugin on git plugin install installs the plugin locally plugin update updates the plugin logdump &lt;description&gt; dump logs to $LOGDUMP instead of uploading Command Line Client Development The command line client is located at \/volumio\/app\/plugins\/system_controller\/volumio_command_line_client\/volumio.sh While some dynamic commands (like volume controls) are located at \/volumio\/app\/plugins\/system_controller\/volumio_command_line_client\/commands","tags":"","url":"API\/Command_Line_Client.html"},{"title":"Plugin System Overview","text":"Introduction Volumio2 introduces the concept of plugins to expand its functionality, and allow an easy sharing of the tweaks and improvements usually generated by the community. We've worked hard to create a standardized layout to make it easier to develop any kind of plugin. If you feel that your particular use case is not covered, please open an issue or discussion at the plugins repo: https:\/\/github.com\/volumio\/volumio-plugins What is plugin ? A plugin is meant to add one specific functionality. It could be music_service, system features, audio interface add on and almost everything developers (Volumio and community) can imagine. There is two kinds of plugin : Official plugin : Plugin approved by the Volumio team and available through the webUI plugins page. Unofficial plugin : Not (yet) approved plugin. Most of the time from the community. For advanced users only and for testing. Requires some command line to be installed. It's better to wait for it to be approved... How to install an official plugin ? Plugins can be installed via Volumio's UI, by selecting the &quot;Plugins&quot; menu entry : From there you will be able to browse the Online Plugin Repository : Select the plugin you want to install by clicking install on the right side. Once installed, you have to click on Installed plugins tab and enable it : Depending on the plugin, you may have to go in Settings for the plugin to enter credentials (Spotify), set the GPIO or Equalizer. How to install an unoffical plugin ? Warning: Even if installing an unofficial plugin won't burn your house or kill your dog, it can result as an unstable system, or non functionnal and you may have to reset or reflash your SD card and loose your settings. So it is reserved to advanced user, to test or help the dev. Once it is said, this is how to proceed. In the example, we are going to install volprametriceq, a Parametric Equalizer. Of course, for another plugin, you have to adapt the path and the name of the plugin: 1) Activate SSH on your system : SSH 2) Connect to your device via your console (linux) or Putty (Windows) 3) Download the plugin: wget https:\/\/github.com\/balbuze\/volumio-plugins\/raw\/master\/plugins\/audio_interface\/volparametriceq\/volparametriceq.zip. 4) Now create a temporary folder mkdir .\/volparametriceq 5) Unzip the previously downloaded file miniunzip volparametriceq.zip -d .\/volparametriceq 6) Go to this folder cd .\/volparametriceq 7) Install the plugins volumio plugin install and wait. It can last several minutes if a lot of packages need to be download. Then : 8) Remove all temporary files : cd .. rm -Rf volparametriceq 9) In the webUI, go to installed plugins section and enable the plugin. 10) If required, go in the plugin settings. Enjoy ! Technical overview of a plugin It is provided as zip file which contains all needed files for it to work, either directly included in the zip file or available via a an install script that will download them automatically. Plugins are located under \/data\/plugins\/ And they are organized in subfolder per categories. When installing plugin, a folder is created in: \/data\/plugins\/mycategory\/myplugins All plugins related files (extracted from zip and resulting from install sh script will be found here). Existing Plugin Categories PLEASE NOTE: Categories name must be lowercase and separated by _ . audio_interface This typically collects plugins that add an audio interface, aka an external and not browsable music source. Typical examples are: Airplay UpNp Bluetooth Equalizer, DSP... music_service Those are browsable music sources, typically: MPD (for local files) Webradios Directories Streaming Services like Spotify miscellanea Those plugins that are too general purpose to classify. Furthermore they are meant to work as standalone units, and they don't require interaction with other plugins. Examples: Appearance Plugins system_controller Those are usually core-plugins, meant to handle vital parts of Volumio. Networking Network Attached Storage Core updater services user_interface Those plugins are meant to allow external communication to Volumio. Developing a new one will be useful to add API Rest Capability, or to extend Volumio interoperability with third party apps and controllers. Some examples: MPD Client Protocol emulation Squeeze Box emulation Phisical button controller What features can be added This features could be miscellaneous, such as new online music provider, new radio stream, management of the GPIO (for supported devices), various DSP, display and plenty of other useful things ! The only limitation is your imagination ! A good way to understand how is made a plugin, is to browse \/volumio\/app\/plugins folder and \/data\/plugins folder. You\u00e2\u0080\u0099ll find inspiration for your own dev ! Plugin Configuration files While first start, Volumio will create a folder that contains saved parameter in a config.json stored in: \/data\/configuration\/mycategory\/myplugins The plugins.json file The plugins.json file stores the status of core (found in \/volumio\/app\/plugins\/plugins.json folder) and extra (found in \/data\/plugins\/plugins.json ) plugins. IMPORTANT : If you create a new plugin MANUALLY, you MUST add a plugin reference to plugins.json files (in \/data\/plugins\/plugins.json). If such reference is not found, volumio will automatically delete your plugin folder. The plugins json contains informations on plugins status: Enabled, which can be true or false Started, which can be true or false Add your information under your plugin relevant category. For example, if I'm adding a music_service plugin called &quot;google_music&quot;, the relevant section will look like { &quot;music_service&quot;: { &quot;google_music&quot;: { &quot;enabled&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: true }, &quot;status&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;STARTED&quot; } }, ...","tags":"","url":"Plugin_System\/Plugin_System_Overview.html"},{"title":"Writing A Plugin","text":"Create your plugin The plugin helper utility allows you to easily create your own plugin, by providing tools for the main steps. Its functions are: volumio plugin volumio plugin init volumio plugin refresh volumio plugin package volumio plugin publish volumio plugin install volumio plugin update volumio plugin This command will simply show you a review of the usage of the utility, as follows: ---- VOLUMIO PLUGIN HELPER ---- This utility helps you creating new plugins for Volumio. Options: init creates a new plugin refresh copies the plugin in the system package compresses the plugin publish publishes the plugin on git volumio plugin init Call the utility with this command to create a new plugin from scratch. First of all it will copy the repository, then create the appropriate folder as specified by the user and prepare all the basic files, finally it will install your plugin locally. Here a step by step example: ATTENTION: The first step is cloning the volumio-plugins repository, just head there and click \"fork\" on top right corner volumio@volumio:~$ volumio plugin init Welcome to the Volumio Plugin Creator! You have to decide which category your plugin belongs to, then you have to select a name for it, leave us the rest Warning: make meaningful choices, you cannot change them later! Creating a new plugin ? volumio plugins folder non existent, please type your github username Ghembs cloning repo: git clone https:\/\/github.com\/Ghembs\/volumio-plugins.git Cloning into '\/home\/volumio\/volumio-plugins'... Done, please run command again volumio@volumio:~$ volumio plugin init Welcome to the Volumio Plugin Creator! You have to decide which category your plugin belongs to, then you have to select a name for it, leave us the rest ;) Warning: make meaningful choices, you cannot change them later! Creating a new plugin ? Please select the Plugin Category 1) audio_interface 2) miscellanea 3) music_service 4) system_controller 5) user_interface Answer: 1 Creating a new plugin ? Please select the Plugin Category audio_interface ? Please insert a name for your plugin test NAME: test CATEGORY: audio_interface Copying sample files ? Please insert your name (Volumio Team) ? Insert a brief description of your plugin (100 chars) test plugin Installing dependencies locally npm WARN test@1.0.0 No repository field. Congratulation, your plugin has been succesfully created! You can find it in: \/home\/volumio\/volumio-plugins\/plugins\/audio_interface\/test After you selected a category and a name for the plugin, it will ask for yours, (Volumio team is the default name), then for a description and finally it will create it and install it locally (\/data\/plugins\/...). downloading\/installing dependencies If you need npm packages for your plugin you might want to install the build-essential package to be able to download and compile packages using the node package manager (npm). volumio@volumio:~$ sudo apt-get install build-essential You can now install package from npm by using the simple command npm install {package name}, e.g. npm install epoll volumio plugin refresh Call the utility with this command if you worked on the source and you want a plugin to be updated locally (\/data\/plugins\/...). You have to call it from an appropriate plugin folder, in the path of volumio-plugins. volumio@volumio:~\/volumio-plugins\/plugins\/audio_interface\/test$ volumio plugin refresh This command will copy all your plugin\\'s file in the correspondent folder in data Updating the plugin in Data Plugin succesfully refreshed volumio plugin package Call the utility with this command if you want to create a package with the content of a plugin's folder. It will take care of npm dependencies and put the zip in the same folder. volumio@volumio:~\/volumio-plugins\/plugins\/audio_interface\/test$ volumio plugin package This command will create a package with your plugin Compressing the plugin No modules found, running &quot;npm install&quot; npm WARN test@1.0.0 No repository field. Plugin succesfully compressed You can find more details below about the zip file and the contents you must have in your plugin's folder volumio plugin publish Call the utility with this command if you want to upload your plugin on github. It will automatically call the package function if no .zip has been found, after asking for a last change in versioning, then it will change branch and, depending on if the plugin and\/or category has been found on the plugins.json file, it will ask for additional details or both details and description. Finally it will commit them and push them on your repo. volumio@volumio:~\/volumio-plugins\/plugins\/audio_interface\/test$ volumio plugin publish This command will publish the plugin on volumio plugins store Publishing the plugin ? do you want to change your version? (leave blank for default) 1.0.0 Switched to branch 'gh-pages' ? Insert some details about your plugin (e.g. features, requirements, notes, etc ... max 1000 chars) plugin for documentation purposes updating plugin sources: \/usr\/bin\/git push origin master updating plugin packages: \/usr\/bin\/git push origin gh-pages Congratulations, your package has been correctly uploaded and is ready for merging! The plugins.json file should now contain all the informations about your plugin, as follow: { &quot;prettyName&quot;:&quot;audiointerface&quot;, &quot;name&quot;:&quot;audio_interface&quot;, &quot;id&quot;:&quot;cat5&quot;, &quot;description&quot;:&quot;&quot;, &quot;plugins&quot;: [ { &quot;prettyName&quot;:&quot;test&quot;, &quot;icon&quot;:&quot;fa-lightbulb-o&quot;, &quot;name&quot;:&quot;test&quot;, &quot;version&quot;:&quot;1.0.0&quot;, &quot;url&quot;:&quot;http:\/\/volumio.github.io\/volumio-plugins\/plugins\/volumio\/armhf\/audio_interface\/test\/test.zip&quot;, &quot;license&quot;:&quot;ISC&quot;, &quot;description&quot;:&quot;test plugin&quot;, &quot;details&quot;:&quot;plugin for documentation purposes&quot;, &quot;author&quot;:&quot;Volumio Team&quot;, &quot;screenshots&quot;:[{&quot;image&quot;:&quot;&quot;,&quot;thumb&quot;:&quot;&quot;}], &quot;updated&quot;:&quot;2-6-2017&quot; } ] } ATTENTION: Your plugin is not published yet. All you need to do is create a pull request, this will initiate the review process by Volumio Team. If everything looks good, your plugin will be published in the Volumio plugins store. volumio plugin install Call the utility with this command if you just downloaded a plugin and wish to install it. You should be in the plugin folder, containing a proper package.json file. volumio@volumio:~\/volumio-plugins\/plugins\/accessory\/ir_controller$ volumio plugin install This command will install the plugin on your device Compressing the plugin Plugin succesfully compressed Progress: 10 Status :Downloading plugin Progress: 30 Status :Creating folder on disk Progress: 40 Status :Unpacking plugin Progress: 50 Status :Checking for duplicate plugin Progress: 60 Status :Copying Plugin into location Progress: 70 Status :Installing dependencies Progress: 70 Status :Installing dependencies Progress: 70 Status :Installing dependencies Progress: 90 Status :Adding plugin to registry Progress: 100 Status :Plugin Successfully Installed Done! volumio plugin update Call the utility with this command if you just downloaded a more recent version of a plugin you've already installed and activated, to update it. You should be in the plugin folder, containing a proper package.json file. volumio@volumio:~\/volumio-plugins\/plugins\/accessory\/ir_controller$ volumio plugin update This command will update the plugin on your device Compressing the plugin Plugin succesfully compressed Progress: 10 Status :Downloading plugin Progress: 20 Status :Plugin stopped Progress: 30 Status :Creating folder on disk Progress: 40 Status :Unpacking plugin Progress: 60 Status :Updating Plugin Files Progress: 70 Status :Installing dependencies Progress: 70 Status :Installing dependencies Progress: 70 Status :Installing dependencies Progress: 90 Status :Adding plugin to registry Progress: 100 Status :Plugin Successfully Installed Done! Volumio plugin files description The Plugin Zip File The plugin zip file will be created as the last step of the plugin creation and it must contains : Mandatory Files Name Format Content install.sh Bash script this file contains a script of action and dependencies installation needed for the plugin. It\u00e2\u0080\u0099s a BASH script. It MUST be executable. index.js javascript this is main file, written in node.js node_modules folder folder that contains all node modules needed config.json json this file contains all the parameters to be save for the plugin. Package.json json this file contains description of the plugin and the list of required node dependencies Uninstall.sh Bash script this file contains the script to remove the plugin. CAREFUL: The zip must contain the files in the plugins root folder, NOT the root folder itself! Details and examples of mandatories files. Here you will find more details for each files listed above, what they contain, how to write a working plugin. Examples based on Spop plugin. Install.sh This file allows download and installation of dependencies for the plugin. It\u00e2\u0080\u0099s a executable file written in BASH. #!\/bin\/bash echo &quot;Installing Spop Dependencies&quot; sudo apt-get update sudo apt-get -y install libasound2-dev libreadline-dev libsox-dev libsoup2.4-dev libsoup2.4-1 libdbus-glib-1-dev libnotify-dev --no-install-recommends echo &quot;Installing Spop and libspotify&quot; DPKG_ARCH=`dpkg --print-architecture` echo $DPKG_ARCH cd \/tmp wget http:\/\/repo.volumio.org\/Packages\/Spop\/spop-${DPKG_ARCH}.tar.gz sudo tar xvf \/tmp\/spop-${DPKG_ARCH}.tar.gz -C \/ rm \/tmp\/spop-${DPKG_ARCH}.tar.gz sudo chmod 777 \/etc\/spopd.conf #required to end the plugin install echo &quot;plugininstallend&quot; IMPORTANT THINGS TO NOTICE Use &quot;echo&quot; to detail what's going during the install, this will help you debugging, and notify the user what goes on during install Since we are installing compiled binaries (that need to be compiled for both x86 and armhf, using dpkg --print-architecture as part of the file name will ensure an architecture-agnostic script) For security reasons dpkg is not allowed, so if you need to install binaries, tar them and download the tar accordingly We have no environment variable set, so make sure you cd in the desired folder Ensure to give proper permissions to file you'll need to edit later on (node runs with user volumio) To avoid installing unwanted stuff, make sure to place --no-install-recommends after your to-install list echo &quot;plugininstallend&quot; must be placed at the end of the install script to signal that installation has ended. Index.js Index.js This file is the main file of the plugin. It is written in javascript. Please refer to index.js section for a detailed explanation. config.json File in which is saved default parameters, and the way saved parameters will be saved. { &quot;enabled&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: false }, &quot;username&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;password&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;value&quot;: &quot;&quot; }, &quot;bitrate&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;value&quot;: true } } package.json This file contains package description and dependencies { &quot;name&quot;: &quot;spop&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Spotify plugin for Volumio2&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;volumio_info&quot;: { &quot;prettyName&quot;: &quot;Spotify&quot;, &quot;icon&quot;: &quot;fa-spotify&quot;, &quot;plugin_type&quot;: &quot;music_service&quot;, &quot;boot_priority&quot;:1 }, &quot;dependencies&quot;: { &quot;fast.js&quot;: &quot;^0.1.1&quot;, &quot;fs-extra&quot;: &quot;^0.28.0&quot;, &quot;kew&quot;: &quot;^0.7.0&quot;, &quot;net&quot;: &quot;^1.0.2&quot;, &quot;nodetools&quot;: &quot;^1.0.0&quot;, &quot;spotify-web-api-node&quot;: &quot;^2.3.0&quot;, &quot;v-conf&quot;: &quot;^0.10.0&quot; } } IMPORTANT THINGS TO NOTICE The relevant parts are: name: this will be the plugin's name folder licence: use any licence, you're not bound to GPL here dependencies: indicate the node modules this plugin requres, to avoid yourself the extra hassle of 2 different zip files for x86 and ARM, try to choose node modules that don't need to be compiled or rely on external dependencies make sure to indicate propery the pretty name, icon and plugin type. The more straightforward, the better version, this is used to keep track of version and request for updates if new versions are found boot priority, accepts a numerical value from 1 to 10. Useful if you need to start your plugin after one another. 1 means it is started first, 10 means it will be started at last. Uninstall.sh Bash file. As install file MUST be executable. Here you will basically revert what you did in the install.sh file . Name Format Content i18n folder contains string_en.json and other strings to translate the plugin Uiconfig.json json this file describe the UI of the plugin. Other Text, image, sound, script, executable... required file \/ script to use in the plugin such as executable or service,image, sound, application key... RequiredConf.json json Configuration key or variables mandatory for the plugin to work. Useful to add a new parameter with an update Details and examples of optional files Depending on the plugin, other file may be nedeed. UIConfig.json This file describes the user interface for the plugin configuration, that will appear while clicking on the cog. Please note that the filename is case sensitive. Please refer to UI Configuration Pages for reference. I18n This folder contains languages strings if you want to translate your plugin You have to have one file per language. The file naming is \u00e2\u0080\u009cstrings_en.json\u00e2\u0080\u009d for english. Of course replace \u00e2\u0080\u009cen\u00e2\u0080\u009d by the language to be translated \u00e2\u0080\u009cit\u00e2\u0080\u009d, \u00e2\u0080\u009cfr\u00e2\u0080\u009d, \u00e2\u0080\u009ces\u00e2\u0080\u009d. This is a json file. { &quot;spotify_username&quot;:&quot;Spotify username&quot;, &quot;spotify_password&quot;:&quot;Spotify password&quot;, &quot;high_bitrate&quot;:&quot;High quality&quot;, &quot;search_results&quot;:&quot;Number of results&quot;, &quot;plugins&quot;:&quot;Last.fm&quot;, &quot;last_fm_username&quot;:&quot;Last.fm username&quot;, &quot;last_fm_password&quot;:&quot;Last.fm password&quot;, &quot;SEARCH_SONGS_SECTION&quot;:&quot;Spotify songs&quot;, &quot;SEARCH_ALBUMS_SECTION&quot;:&quot;Spotity albums&quot;, &quot;SEARCH_ARTISTS_SECTION&quot;:&quot;Spotify artists&quot; } Other Your plugin may require other files such as image, sound, executable, configuration files etc\u00e2\u0080\u00a6 You have to include these files in the ZIP file and ensure proper permissions if they'll need to be edited. Publish your plugin When you want to provide your plugin to other people it is best practice to start development by forking the volumio-plugins repository. Start developing directly in the master branch and create a pull request when you are done.","tags":"","url":"Plugin_System\/Writing_A_Plugin.html"},{"title":"Index.js","text":"Index.js aka the plugin's core The index.js file of every plugin is where the magic goes on. It has some predefined and mandatory functions and a standardized layout. Depending on you'r plugin's category, this structure needs to change accordingly. We'll start by detailing a generic plugin structure. Generic structure The first part is about module dependencies, we'll need to list all the node modules our plugin depends on (example taken from Spotify plugin). 'use strict'; var libQ = require('kew'); var libNet = require('net'); var libFast = require('fast.js'); var fs=require('fs-extra'); var config = new (require('v-conf'))(); var exec = require('child_process').exec; var SpotifyWebApi = require('spotify-web-api-node'); var nodetools = require('nodetools'); IMPORTANT TIPS: Node modules allow you to develop faster, by relaying on already-written code to overcome the majority of tasks, to look for them search here The 'use strict'; declaration at the beginning will ensure no obvious coding mispractices will happen, more info on the matter Use the minimum amount of modules needed, and try to avoid modules that needs compilation (you will spot those because they'll take longer on npm install), so you will avoid to mantain two separate versions for x86 and arm architectures. Then we will define the plugin class and reference to other core Volumio's internals: module.exports = ControllerSpop; function ControllerSpop(context) { \/\/ This fixed variable will let us refer to 'this' object at deeper scopes var self = this; this.context = context; this.commandRouter = this.context.coreCommand; this.logger = this.context.logger; this.configManager = this.context.configManager; } IMPORTANT TIPS: Substitute ControllerSpop with something that resembles your plugin name. For example ControllerGPIO or ControllerSoundcloud We'll start every prototype (see later) with this Controller naming Then we add all the required functions for a generic plugin: On Volumio Start This is the code that gets executed when Volumio starts and triggers the plugin start. Typically, what you do is load the plugin configuration. ControllerSpop.prototype.onVolumioStart = function() { var configFile=this.commandRouter.pluginManager.getConfigurationFile(this.context,'config.json'); this.config = new (require('v-conf'))(); this.config.loadFile(configFile); } On Start This instead is what happens when the Plugin starts. It's different from On Volumio Start since this function is triggered only if the plugin is enabled. In this case we're starting the spop daemon (responsible for Spotify Playback). ControllerSpop.prototype.onStart = function() { var self = this; var defer=libQ.defer(); self.startSpopDaemon() .then(function(e) { setTimeout(function () { self.logger.info(&quot;Connecting to daemon&quot;); self.spopDaemonConnect(defer); }, 5000); }) .fail(function(e) { defer.reject(new Error()); }); this.commandRouter.sharedVars.registerCallback('alsa.outputdevice', this.rebuildSPOPDAndRestartDaemon.bind(this)); return defer.promise; }; IMPORTANT: You'll notice that we use promises here. That's why Volumio needs to know when the plugin has actually started, or if it failed. So what we're doing is returning the promise on successful start, and rejecting it if it doesn't start properly. The strange function this.commandRouter.sharedVars.registerCallback('alsa.outputdevice', this.rebuildSPOPDAndRestartDaemon.bind(this)); does one important thing. It binds to a shared system value (alsa.outputdevice, which is the output device) and when it changes it triggers the function rebuildSPOPDAndRestartDaemon that rewrites spop config file and restarts it. On stop When a plugin is stopped, this function gets executed. What we're doing here is killing the spop daemon. We must resolve the promise to signal everything was ok ControllerSpop.prototype.onStop = function() { var self = this; self.logger.info(&quot;Killing SpopD daemon&quot;); exec(&quot;\/usr\/bin\/sudo \/usr\/bin\/killall spopd&quot;, function (error, stdout, stderr) { if(error){ self.logger.info('Cannot kill spop Daemon') } }); return libQ.resolve(); }; Get Configuration files Very straightforwarding, we load the .json configuration file for this plugin. ControllerSpop.prototype.getConfigurationFiles = function() { return ['config.json']; } Get UI configuration This function is triggered when we want to access the plugin configuration. For a better understanding of the configuration pages see Configuration Pages ControllerSpop.prototype.getUIConfig = function() { var defer = libQ.defer(); var self = this; var lang_code = this.commandRouter.sharedVars.get('language_code'); self.commandRouter.i18nJson(__dirname+'\/i18n\/strings_'+lang_code+'.json', __dirname+'\/i18n\/strings_en.json', __dirname + '\/UIConfig.json') .then(function(uiconf) { uiconf.sections[0].content[0].value = self.config.get('username'); uiconf.sections[0].content[1].value = self.config.get('password'); uiconf.sections[0].content[2].value = self.config.get('bitrate'); defer.resolve(uiconf); }) .fail(function() { defer.reject(new Error()); }); return defer.promise; }; IMPORTANT: With var lang_code = this.commandRouter.sharedVars.get('language_code'); we retrieve the current language code. If translation is provided under the \/i18n\/ folder, we'll translate the configuration page, if not we'll default to english. We use promises here as well, since it will take some time to parse the UIConfig.json and translate it. Not using promises will result in configuration not working. With uiconf.sections[0].content[0].value = self.config.get('username'); we're simply subsituting the first element's value of the first section with the username value taken from the plugins configuration. That's how we can populate the UI Configuration Page with actual values. Optional functions for generic plugins Get configuration from other plugins There are cases where we want to get configuration parameters from other plugins, for example to know if an i2s DAC has been enabled or not. We will then use the executeOnPlugin method which will allow us to execute any method on any plugin. For code clarity we wrapped it into the getAdditionalConf function, accepting 3 parameters which are mandatory for the aforementioned executeOnPlugin: TYPE (plugin category) CONTROLLER (plugin name) DATA (the configuration parameter we want to get) Please note that the function to get config parameters is not always getConfigParam but could be also just getConf. Check the individual plugin to see which is the correct function. ControllerAlsa.prototype.getAdditionalConf = function (type, controller, data) { var self = this; return self.commandRouter.executeOnPlugin(type, controller, 'getConfigParam', data); }; Set configuration from other plugins Same as above, also here setConfigParamcould be also setConf or setUiConfig. Check the individual plugin to see which is the correct function. UpnpInterface.prototype.setAdditionalConf = function () { var self = this; return self.commandRouter.executeOnPlugin(type, controller, 'setConfigParam', data); }; Restart Sometimes it might be useful to have a function to restart the plugin. Here's an example for upnp interface in Volumio. UpnpInterface.prototype.onRestart = function () { var self = this; exec('\/usr\/bin\/sudo \/usr\/bin\/killall upmpdcli', function (error, stdout, stderr) { if (error) { self.logger.error('Cannot kill upmpdcli '+error); } self.startUpmpdcli(); }); };","tags":"","url":"Plugin_System\/Index.js.html"},{"title":"UI Configuration Pages","text":"The Configuration Pages To allow an easy development of plugin, we need a structured but still flexible way to configure plugins. Volumio uses a json based markup languages to describe the visual and functional aspects of configuration pages. This supports multilanguage and should be flexible enough to allow any kind of setting to be modified. If you feel your case is not covered, feel free to open an issue or discussion at https:\/\/github.com\/volumio\/Volumio2\/ Introduction Configurations resides on single .json files, pertaining to a core component or a specific plugin. This file is UIConfig.json and it's interpreted by the getUIConfig function present in every plugin. The very same system is used by both Volumio core plugins and community developed plugins, the only difference is that for core functions (such as Wi-fi browser, NAS Browser and some others) we developed special controllers in the UI. You can take a look at them in the core elements part of Volumio2 UI . This the flow of events that results in the visualization of the configuration page: Click on cog wheel, this sends the message getUiConfig for the category and plugin name CommandRouter forwards it to the Plugins The Plugin executes the getUIConfig function which parses and handles the UIConfig.json file Once this is done, it returns the full config, which is a json based object. UI parses it and visualizes it Upon saving, data is sent back as an object The UIConfig.json file It's the json file which describes visually and functionally the configuration page. A very simple example is spotify's plugin config file: { &quot;page&quot;: { &quot;label&quot;: &quot;Spotify Configuration&quot; }, &quot;sections&quot;: [ { &quot;id&quot;: &quot;section_account&quot;, &quot;element&quot;: &quot;section&quot;, &quot;label&quot;: &quot;Spotify account&quot;, &quot;icon&quot;: &quot;fa-plug&quot;, &quot;onSave&quot;: {&quot;type&quot;:&quot;controller&quot;, &quot;endpoint&quot;:&quot;music_service\/spop&quot;, &quot;method&quot;:&quot;saveSpotifyAccount&quot;}, &quot;saveButton&quot;: { &quot;label&quot;: &quot;Save&quot;, &quot;data&quot;: [ &quot;username&quot;, &quot;password&quot;, &quot;bitrate&quot; ] }, &quot;content&quot;: [ { &quot;id&quot;: &quot;username&quot;, &quot;type&quot;:&quot;text&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the username of your Spotify account&quot;, &quot;label&quot;: &quot;Username&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;id&quot;: &quot;password&quot;, &quot;type&quot;:&quot;password&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the password of your Spotify account&quot;, &quot;label&quot;: &quot;Password&quot;, &quot;value&quot;: &quot;&quot; }, { &quot;id&quot;:&quot;bitrate&quot;, &quot;element&quot;: &quot;switch&quot;, &quot;doc&quot;: &quot;High bitrate&quot;, &quot;label&quot;: &quot;Set for high bitrate&quot;, &quot;value&quot;: true } ] } ] } Let's break it down and analyze in its sections: &quot;page&quot;: { &quot;label&quot;: &quot;Spotify Configuration&quot; } This is the Page's tite. &quot;sections&quot;: [ { &quot;id&quot;: &quot;section_account&quot;, &quot;element&quot;: &quot;section&quot;, &quot;label&quot;: &quot;Spotify account&quot;, &quot;icon&quot;: &quot;fa-plug&quot;, &quot;onSave&quot;: {&quot;type&quot;:&quot;controller&quot;, &quot;endpoint&quot;:&quot;music_service\/spop&quot;, &quot;method&quot;:&quot;saveSpotifyAccount&quot;}, &quot;saveButton&quot;: { &quot;label&quot;: &quot;Save&quot;, &quot;data&quot;: [ &quot;username&quot;, &quot;password&quot;, &quot;bitrate&quot; ] } Those are the sections descriptors. A section is typically a block of options which are related one to each other. Each section has: id : used to identify it element: the type, which is of course section label: the title of the section icon: the icon showed, it's a font-awesome icon onSave: it's the function invoked in the plugin index.js file, the payload will be a json object (see saveButton data item) saveButton label : pretty self-explanatory saveButton data : this will be the payload sent along, taking data from the elements into the array. In the case above the payload will be {&quot;username&quot;:usernameset,&quot;password&quot;:passwordset,&quot;bitrate&quot;:bitratedata}. Failing to add elements to the array will not result in a crash, the info\/settings will just be omitted from the payload. &quot;content&quot;: [ { &quot;id&quot;: &quot;username&quot;, &quot;type&quot;:&quot;text&quot;, &quot;element&quot;: &quot;input&quot;, &quot;doc&quot;: &quot;This is the username of your Spotify account&quot;, &quot;label&quot;: &quot;Username&quot;, &quot;value&quot;: &quot;&quot; } Content defines all the elements available in a section. It needs the following fields: id : the id, this one is the one referred in saveButton data type : type of the element, for a comprehensive list of examples see later doc : an explanation of what the field does, please try to use translations as opposed to static text, that way anyone can translate it into their own language. label: label, please try to use translations as opposed to static text, that way anyone can translate it into their own language. value: this is the current value of the element, can be manipulated in the getUIConfig function. It can be either a boolean (true | false), a string or a number. Optionally, you can also require a confirmation popup by adding the entry 'askForConfirm': {'title': 'Confirm', 'message': 'Do you want to save this values?'} If you want to hide or show an element dynamically based on the state on another option (in the same section), you can use 'visibleIf': {'field': 'spotify_service', 'value': true} Element Types Text input 'id': 'playerName', 'element': 'input', 'type': 'text', 'label': 'Player Name', 'attributes': [ {'placeholder': 'call me with a fancy name'}, {'maxlength': 10} ], 'value': 'Volumio' switch 'id': 'airplay', 'element': 'switch', 'label': 'Airplay', 'description': 'Apple airplay', 'value': true select 'id': 'kernel_profile', 'element': 'select', 'label': 'Kernel profile', 'value': {'value': 2 ,'label': 'Less Jitter'}, 'options': [ { 'value': 1, 'label': 'Default' }, { 'value': 2, 'label': 'Less Jitter' }, { 'value': 3, 'label': 'Jitter' }, { 'value': 4, 'label': 'Focus' } ] button 1: Open a modal to ask for confirmation before emitting data and message 'id': 'update', 'element': 'button', 'label': 'System updates', 'description': 'You can check?...', 'onClick': { 'type': 'emit', 'data': 'search-for-upgrade', 'message': 'updateCheck', 'askForConfirm': {'title': 'Confirm', 'message': 'are you sure?'} button 2: Directly emit data and message 'id':'albumartcache', 'element': 'button', 'label': 'TRANSLATE.APPEARANCE.ALBUMART_RESET_CACHE', 'doc': 'TRANSLATE.APPEARANCE.ALBUMART_RESET_CACHE_DOC', 'onClick': {'type':&quot;emit', 'message':'callMethod', 'data':{'endpoint':'miscellanea\/albumart','method':'clearAlbumartCache','data':''}} button 3: Open a URL in a new page 'id':'volumiolink', 'element': 'button', 'label': 'Go To Volumio Website', 'description&quot;: 'Open Volumio Website', 'onClick': {'type':'openUrl', 'url':'https:\/\/volumio.org'} Equalizer 'id': 'eq', 'type': 'section', 'label': 'Equalizer', 'onSave': { 'type': 'plugin', 'endpoint': 'music_services\/eq', 'method': 'saveEqValues' }, 'saveButton': { 'label': 'Save eq settings', 'data': [ 'bandEqualizer', 'equalizerSelector' ] }, 'content': [ { 'id': 'eq_switch', 'element': 'switch', 'label': 'Test eq switch', 'value': true }, { 'id': 'bandEqualizer', 'element': 'equalizer', 'label': 'Music EQ', 'description': 'Desc', 'visibleIf': {'field': 'eq_switch', 'value': true}, 'config': { orientation: 'vertical', bars: [ { min: -100, max: 100, step: 20, value: 20, tooltip: 'always' }, { min: 0, max: 50, step: 20, value: 25, tooltip: 'hide' }, { min: 0, max: 50, step: 20, value: 25, tooltip: 'always' } ] } } Equalizer Selector { 'id': 'equalizerSelector', 'element': 'equalizer', 'label': 'Slider selector', 'description': 'Desc', 'config': { orientation: 'horizontal', bars: [ { min: 0, max: 50, step: 10, value: [10, 20], range: true, tooltip: 'always' }, { ticks: [1, 2, 3], ticksLabels: ['Min', 'Medium', 'Max'], value: 2, tooltip: 'show' }, { ticks: [1, 2, 3, 4, 5], ticksPositions: [0, 20, 40, 80, 100], ticksLabels: ['1', '2', '3', '4', '5'], tickSnapBounds: 20, value: 4, tooltip: 'show' } Translating text In order to allow people to translate the plugin into their own languages it is advised to use translations as opposed to static lines of text. It only takes up a little more time, but saves time in the long run. Requirements: i18n module (it needs to be places in the node_modules directory) a i18n directory with at least one (preferably (also) English) language file e.g.: strings_en.json You can translate strings by calling the TRANSLATE command in the text field followed by any number of nodes, you can make it as complex as you want, but keep it readable please. Example of a UIConfig element 'id': 'docs', 'element': 'input', 'doc': 'TRANSLATE.DOCS.WHYSHOULDITRANSLATE', 'label': 'TRANSLATE.DOCS.EXAMPLE', 'description': 'TRANSLATE.DOCS.DESC', 'value': true The following is an example of a translation snippet. { &quot;DOCS&quot;:{ &quot;WHYSHOULDITRANSLATE&quot;:&quot;Translation allow for neater integration into systems with other languages&quot;, &quot;EXAMPLE&quot;:&quot;Please translate this to your own language&quot;, &quot;DESC&quot;:&quot;You can fill in any translation here&quot;, ... You don't need to use all caps if you don't want to, I use those because they stand out like that.","tags":"","url":"Plugin_System\/UI_Configuration_Pages.html"},{"title":"Toast Messages","text":"Toast Messages Enable Toast Messages For easier usage make sure you assign the coreCommand instance in the consturctor of your plugin: module.exports = ExamplePlugin; function ExamplePlugin(context) { var self = this; self.context = context; self.commandRouter = this.context.coreCommand; } Create Toast Message At any place in your code you can then call the commandRouter.pushToastMessage method to show a toast messages to the user: self.commandRouter.pushToastMessage('success', &quot;Account Login&quot;, &quot;Login was successful&quot;); There are four kinds of toast messages: info, success, alert and error: self.commandRouter.pushToastMessage('info', &quot;Account Login&quot;, &quot;Login pending....&quot;); self.commandRouter.pushToastMessage('success', &quot;Account Login&quot;, &quot;Login was successful&quot;); self.commandRouter.pushToastMessage('alert', &quot;Account Login&quot;, &quot;Login not possible&quot;); self.commandRouter.pushToastMessage('error', &quot;Account Login&quot;, &quot;Login failed - invalid credentials&quot;);","tags":"","url":"Plugin_System\/Toast_Messages.html"},{"title":"Logging","text":"Logging Enable Logging For easier usage make sure you assign the context.logger instance in the consturctor of your plugin: module.exports = ControllerSpop; function ControllerSpop(context) { var self = this; self.logger = this.context.logger; } Create Log Message At any place in your code you can then call the methods of the logger instance: self.logger.info(&quot;Youtube::onStart Adding to browse sources&quot;); The logger instance has the following methods to create log messages: info, warn, error and debug. Volumio is using winston for logging.","tags":"","url":"Plugin_System\/Logging.html"},{"title":"User Modal","text":"User Modal It is possible to interact with your plugin's user in real time using modals. Here's an example: var modalData = { title: 'Modal', message: 'Something occured, you may react, or close this window', size: 'lg', buttons: [ { name: 'Close', class: 'btn btn-warning' }, { name: 'React', class: 'btn btn-info', emit:'react', payload:'' } ] } self.commandRouter.broadcastMessage(&quot;openModal&quot;, modalData); In the previous example, a modal is created by the plugin at runtime. Whatever button the user presses, the modal will close. The &quot;React&quot; button however will also emit a &quot;react&quot; socketIO event, which can be handled directly by the plugin. This section is potentially incomplete and needs revisiting, but it should work.","tags":"","url":"Plugin_System\/User_Modal.html"},{"title":"Music Service Plugin","text":"Index.js aka the plugin's core for Music Sources Plugins Music sources requires an extra bit of functions to be hooked properly into Volumio. Basically the need to expose their &quot;browsable&quot; structure of data, allow search and provide a translation for their displayed name on Music Sources. Missing any of those will result in a non working plugin, and possibly a broken Volumio. Those are: addToBrowseSources handleBrowseUri explodeUri search Optional functions are: getTrackInfo Folders and Structures In your plugin you may want to show folders and songs. Volmuio knows several different types that offer different functionalities to the user. Those types offer the user the opportunity to add it to its favorites or to a playlist by clicking on the burger mneu: folder song playlist Those types are simply for browsing without additional functionality - the burger menu isn't shown either. item-no-menu Use the type property on the object you are returning the the required and optional functions: { &quot;title&quot;: &quot;Spotify result&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;availableListViews&quot;: [ &quot;list&quot;, &quot;grid&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Vienna&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:5cgSWdlxIelg5N9OjfkRow&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;40 Beers&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:2r6oZ0GBqJaCnqqR72yiFc&quot; } ] } Required Functions Add to Browse sources This functions adds the new music source to Main Browse Menu. Rules to Follow: Invoke this function ONLY when the plugin starts properly, and if you're relying on a daemon only when successful connection has been established with the daemon and the service. Every call to the uri specified here, will be handled by this plugin. Basically, when clicking &quot;Spotify&quot;, we'll handle the request in this plugin via the function and return the sub-categories available. Those will be handled by the handleBrowseUri function later on. ControllerSpop.prototype.addToBrowseSources = function () { var data = {name: 'Spotify', uri: 'spotify',plugin_type:'music_service',plugin_name:'spop'}; this.commandRouter.volumioAddToBrowseSources(data); }; Handle Browse uri This function is responsible to interpret the desired URI (basically the browse point requested) and return the available items. Some examples: Webradios browsing: ControllerWebradio.prototype.handleBrowseUri=function(curUri) { var self=this; var response; if (curUri.startsWith('radio')) { if (curUri == 'radio') response = self.listRoot(curUri); else { if (curUri.startsWith('radio\/myWebRadio')) { response = self.listMyWebRadio(curUri); } if (curUri.startsWith('radio\/byGenre')) { if (curUri == 'radio\/byGenre') response = self.listRadioGenres(curUri); else response = self.listRadioForGenres(curUri); } if (curUri.startsWith('radio\/favourites')) { response = self.listRadioFavourites(curUri); } if (curUri==='radio\/top500') { response = self.listTop500Radios(curUri); } else if (curUri.startsWith('radio\/byCountry')) { if (curUri == 'radio\/byCountry') response = self.listRadioCountries(curUri); else response = self.listRadioForCountry(curUri); } } } return response; } Music Library and playlist browsing: ControllerMpd.prototype.handleBrowseUri = function (curUri) { var self = this; var response; if (curUri.startsWith('music-library')) { response = self.lsInfo(curUri); }else if (curUri.startsWith('playlists')) { if (curUri == 'playlists') response = self.listPlaylists(curUri); else response = self.browsePlaylist(curUri); } return response; }; Spotify browsing ControllerSpop.prototype.handleBrowseUri=function(curUri) { var self=this; \/\/self.commandRouter.logger.info(curUri); var response; if (curUri.startsWith('spotify')) { if(curUri=='spotify') { response=libQ.resolve({ navigation: { prev: { uri: 'spotify' }, lists: [ { &quot;title&quot;: &quot;Spotify Folders&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { service: 'spop', type: 'folder', title: 'My Playlists', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/playlists' }, { service: 'spop', type: 'folder', title: 'Featured Playlists', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/featuredplaylists' }, { service: 'spop', type: 'folder', title: 'What\\'s New', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/new' }, { service: 'spop', type: 'folder', title: 'Genres &amp; Moods', artist: '', album: '', icon: 'fa fa-folder-open-o', uri: 'spotify\/categories' } ] } ] } }); } else if(curUri.startsWith('spotify\/playlists')) { if(curUri=='spotify\/playlists') response=self.listPlaylists(); else { response=self.listPlaylist(curUri); } } else if(curUri.startsWith('spotify\/featuredplaylists')) { response=self.featuredPlaylists(curUri); } else if(curUri.startsWith('spotify\/webplaylist')) { response=self.listWebPlaylist(curUri); } else if(curUri.startsWith('spotify\/new')) { response=self.listWebNew(curUri); } else if(curUri.startsWith('spotify\/categories')) { response=self.listWebCategories(curUri); } else if(curUri.startsWith('spotify\/album')) { response=self.listWebAlbum(curUri); } else if(curUri.startsWith('spotify\/category')) { response=self.listWebCategory(curUri); } else if(curUri.startsWith('spotify:artist:')) { response=self.listWebArtist(curUri); } } return response; }; BEST PRACTICES: Hardcode all expected uris, and handle errors in case you receive an unknown one Use separate functions for every uri tpye Use promises where possible If you use an external API service with API limits, cache where possible. Navigation is nested, so make sure you provide the upper level (needed for going back while browsing) You can display an icon by using icon and using a font-awesome icon You can display an image by using albumart, you can then pass a direct url or use the Albumart Server The albumart API is: \/albumart?web=artist\/album\/large&amp;path=path all encoded which becomes \/albumart?web=Alabama%20Shakes\/Sound%20%26%20Color\/large&amp;path=%2FUSB%2FALABAMA%20SHAKES%20S%20%26%20C The title and icon attributes are used to divide sections with different content in it, like showing albums and songs for a particular artists. They become separators. The availableListViews attribute is used to indicate the visualizations options available for this particular list of items. Generally folders, albums and artists have both list and grid views available, while tracks and genres are visualized only in list mode. GENERIC OUTPUT EXAMPLE: { &quot;navigation&quot;: { &quot;lists&quot;: [ { &quot;title&quot;: &quot;Artists&quot;, &quot;icon&quot;: &quot;fa icon&quot;, &quot;availableListViews&quot;: [ &quot;list&quot;, &quot;grid&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Led Zeppelin&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;search:\/\/artist\/Led Zeppelin&quot; } ] }, { &quot;title&quot;: &quot;Webradios&quot;, &quot;icon&quot;: &quot;&quot;, &quot;availableListViews&quot;: [ &quot;list&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;ledjam&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=492072&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;NAXI 80-e RADIO (NAXI,Belgrade,Serbia, NAXI,Beograd,Srbija) - 128k&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=68544&quot; } ] } ], &quot;prev&quot;: { &quot;uri&quot;: &quot;\/&quot; } } } EXPECTED RESULTS EXAMPLES: Local folders { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;music-library&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;Calibro 35 (2008)&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;music-library\/USB\/Calibro 35 (2008)&quot; }, { &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;In Sight&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;music-library\/USB\/In Sight&quot; } ] } ] } } Local files { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;music-library\/USB&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Sound &amp; Color&quot;, &quot;artist&quot;: &quot;Alabama Shakes&quot;, &quot;album&quot;: &quot;Sound &amp; Color&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;music-library\/USB\/ALABAMA SHAKES S &amp; C\/01 Sound &amp; Color.mp3&quot; }, { &quot;service&quot;: &quot;mpd&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Don't Wanna Fight&quot;, &quot;artist&quot;: &quot;Alabama Shakes&quot;, &quot;album&quot;: &quot;Sound &amp; Color&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;uri&quot;: &quot;music-library\/USB\/ALABAMA SHAKES S &amp; C\/02 Don't Wanna Fight.mp3&quot; } ] } ] } } Webradios { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;radio\/byGenre&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;Oldies FM&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=728640&quot; }, { &quot;service&quot;: &quot;webradio&quot;, &quot;type&quot;: &quot;webradio&quot;, &quot;title&quot;: &quot;San Francisco's 70's HITS!&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-microphone&quot;, &quot;uri&quot;: &quot;http:\/\/yp.shoutcast.com\/sbin\/tunein-station.m3u?id=1087995&quot; } ] } ] } } Spotify Categories (similar to local folders) { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;spotify&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;,&quot;grid&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;My Playlists&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;spotify\/playlists&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;folder&quot;, &quot;title&quot;: &quot;Featured Playlists&quot;, &quot;artist&quot;: &quot;&quot;, &quot;album&quot;: &quot;&quot;, &quot;icon&quot;: &quot;fa fa-folder-open-o&quot;, &quot;uri&quot;: &quot;spotify\/featuredplaylists&quot; } ] } ] } } Spotify Songs (streaming plugins) { &quot;navigation&quot;: { &quot;prev&quot;: { &quot;uri&quot;: &quot;spotify&quot; }, &quot;lists&quot;: [ { &quot;availableListViews&quot;: [&quot;list&quot;], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Vienna&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:5cgSWdlxIelg5N9OjfkRow&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;40 Beers&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:2r6oZ0GBqJaCnqqR72yiFc&quot; } ] } ] } } Explode uri This function takes care of retrieving all informations related to a particular URI, it's needed both by queue and state machine. Some examples: Local files (MPD) ControllerMpd.prototype.explodeUri = function(uri) { var self = this; var defer=libQ.defer(); var items = []; var cmd = libMpd.cmd; if(uri.startsWith('search:\/\/')) { \/\/exploding search var splitted=uri.split('\/'); var argument=splitted[2]; var value=splitted[3]; if(argument==='artist') { var commandArtist = 'search artist '+' &quot;' + value + '&quot;'; self.mpdReady.then(function () { self.clientMpd.sendCommand(cmd(commandArtist, []), function (err, msg) { var subList=[]; if (msg) { var lines = msg.split('\\n'); for (var i = 0; i &lt; lines.length; i++) { var line = lines[i]; if (line.startsWith('file:')) { var path = line.slice(5).trimLeft(); var name = path.split('\/'); var count = name.length; var artist = self.searchFor(lines, i + 1, 'Artist:'); var album = self.searchFor(lines, i + 1, 'Album:'); var title = self.searchFor(lines, i + 1, 'Title:'); var time = parseInt(self.searchFor(lines, i + 1, 'Time:')); if (title) { title = title; } else { title = name; } items.push({ uri: 'music-library\/'+path, service: 'mpd', name: title, artist: artist, album: album, type: 'track', tracknumber: 0, albumart: self.getAlbumArt({artist:artist,album: album},uri), duration: time, trackType: 'mp3' }); } } defer.resolve(items); } else if(err) defer.reject(new Error('Artist:' +err)); else defer.resolve(items); }); }); } else if(argument==='album') { var commandAlbum = 'search album '+' &quot;' + value + '&quot;'; self.mpdReady.then(function () { self.clientMpd.sendCommand(cmd(commandAlbum, []), function (err, msg) { var subList=[]; if (msg) { var lines = msg.split('\\n'); for (var i = 0; i &lt; lines.length; i++) { var line = lines[i]; if (line.startsWith('file:')) { var path = line.slice(5).trimLeft(); var name = path.split('\/'); var count = name.length; var artist = self.searchFor(lines, i + 1, 'Artist:'); var album = self.searchFor(lines, i + 1, 'Album:'); var title = self.searchFor(lines, i + 1, 'Title:'); var time = parseInt(self.searchFor(lines, i + 1, 'Time:')); if (title) { title = title; } else { title = name; } items.push({ uri: 'music-library\/' + path, service: 'mpd', name: title, artist: artist, album: album, type: 'track', tracknumber: 0, albumart: self.getAlbumArt({artist: artist, album: album}, uri), duration: time, trackType: 'mp3' }); } } defer.resolve(items); } else if(err) defer.reject(new Error('Artist:' +err)); else defer.resolve(items); }); }); } else defer.reject(new Error()); } else { var uriPath='\/mnt\/'+self.sanitizeUri(uri); self.commandRouter.logger.info('----------------------------'+uriPath); var uris=self.scanFolder(uriPath); var response=[]; libQ.all(uris) .then(function(result) { for(var j in result) { self.commandRouter.logger.info(&quot;-----&gt;&gt;&gt;&gt;&gt; &quot;+JSON.stringify(result[j])); if(result!==undefined &amp;&amp; result[j].uri!==undefined) { response.push({ uri: self.fromPathToUri(result[j].uri), service: 'mpd', name: result[j].name, artist: result[j].artist, album: result[j].album, type: 'track', tracknumber: result[j].tracknumber, albumart: result[j].albumart, duration: result[j].duration, samplerate: result[j].samplerate, bitdepth: result[j].bitdepth, trackType: result[j].trackType }); } } defer.resolve(response); }).fail(function(err) { self.commandRouter.logger.info(&quot;explodeURI: ERROR &quot;+err); defer.resolve([]); }); } return defer.promise; }; Webradio ControllerWebradio.prototype.explodeUri = function(uri) { var self = this; var defer=libQ.defer(); defer.resolve({ uri: uri, service: 'webradio', name: uri, type: 'track' }); return defer.promise; }; Search Every Music Service should provide a search function, but that's not mandatory. A typical search function MUST use promises and return objects formatted exactly like the above browse results. This is what a search backbone look like, where all search results are pushed into a list array and then resolved. Remember to divide search results (like artist, folders etc) with the APIs detailed above (title and icon) and to respect visualization types. ControllerSpop.prototype.search = function (query) { var self=this; var defer=libQ.defer(); defer.resolve(list); }, function (err) { self.logger.info('An error occurred while searching ' + err); }); }); return defer.promise; As result the following structure is expected: { &quot;title&quot;: &quot;Spotify result&quot;, &quot;icon&quot;: &quot;fa fa-music&quot;, &quot;availableListViews&quot;: [ &quot;list&quot;, &quot;grid&quot; ], &quot;items&quot;: [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Vienna&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:5cgSWdlxIelg5N9OjfkRow&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;40 Beers&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:2r6oZ0GBqJaCnqqR72yiFc&quot; } ] } Optional Functions Get Track Info This method is called by volumio when the user adds e.g. a song to a playlist or to the favorites. You have to return a promise that will resolve as soon as you have collected all details about the URI that is passed in as parameter. The expected format is an array containing the following information - the more you provide, the more the UI can visualize (e.g. if you are missing an albumart you can also use the icon property). [ { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;Vienna&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:5cgSWdlxIelg5N9OjfkRow&quot; }, { &quot;service&quot;: &quot;spop&quot;, &quot;type&quot;: &quot;song&quot;, &quot;title&quot;: &quot;40 Beers&quot;, &quot;artist&quot;: &quot;Thom Sonny Green&quot;, &quot;album&quot;: &quot;High Anxiety&quot;, &quot;albumart&quot;: &quot;https:\/\/i.scdn.co\/image\/dac9ef993de0a5758cc6e655080306d40814edc9&quot;, &quot;uri&quot;: &quot;spotify:track:2r6oZ0GBqJaCnqqR72yiFc&quot; } ] The example code is shown from the YouTube plugin: Youtube.prototype.getTrackInfo = function (uri) { var self = this; var deferred = libQ.defer(); if (uri.startsWith('youtube')) { var uriParts = uri.split('\/'); var id = uriParts.pop(); var kind = uriParts.pop(); switch (kind) { case 'playlist': self.getPlaylistItems(id).then(function (playlistItems) { if (playlistItems.navigation.lists.length &gt; 0 &amp;&amp; playlistItems.navigation.lists[0].items.length &gt; 0) { console.log(playlistItems.navigation.lists[0].items) deferred.resolve(playlistItems.navigation.lists[0].items); } else { deferred.reject(new Error('Failed to load playlist info.')); } }); break; case 'video': self.getVideo(id).then(function (videoItems) { console.log(JSON.stringify(videoItems)); if (videoItems.items.length &gt; 0) { deferred.resolve(videoItems.items); } else { deferred.reject(new Error('Failed to load video info.')); } }); break; default: self.logger.error(&quot;Youtube::getTrackInfo unknown uri kind: &quot; + kind); deferred.reject(new Error('Unknown uri kind ' + kind)); break; } } else { self.logger.info(&quot;Youtube::getTrackInfo unknown uri: &quot; + uri); deferred.reject(new Error('Unknown uri ' + uri)); } return deferred.promise; }","tags":"","url":"Plugin_System\/Music_Service_Plugin.html"},{"title":"Adding Compatibility to your DAC","text":"If you're an hardware Audio manufacturer and you've developed a brand new i2s DAC, making it compatible with Volumio is very easy. Prerequisites The kernel driver must be already present in the Kernel that Volumio uses. If that's not true, please contact us The dacs.json file Volumio stores all compatibility data for i2s dac in a single file: the dacs.json file, here's a brief extract of it (August 2nd 2018): { &quot;devices&quot;:[ {&quot;name&quot;:&quot;Raspberry PI&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;adafruit-max98357&quot;,&quot;name&quot;:&quot;Adafruit MAX98357&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;allo-boss-dac&quot;,&quot;name&quot;:&quot;Allo BOSS&quot;,&quot;overlay&quot;:&quot;allo-boss-dac-pcm512x-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;allo-digione&quot;,&quot;name&quot;:&quot;Allo DigiOne&quot;,&quot;overlay&quot;:&quot;allo-digione&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;allo-katana-dac&quot;,&quot;name&quot;:&quot;Allo Katana&quot;,&quot;overlay&quot;:&quot;allo-katana-dac-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Master&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;piano-dac&quot;,&quot;name&quot;:&quot;Allo Piano&quot;,&quot;overlay&quot;:&quot;allo-piano-dac-pcm512x-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;piano-dac-plus&quot;,&quot;name&quot;:&quot;Allo Piano 2.1&quot;,&quot;overlay&quot;:&quot;allo-piano-dac-plus-pcm512x-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;applepi-dac&quot;,&quot;name&quot;:&quot;ApplePi DAC&quot;,&quot;overlay&quot;:&quot;applepi-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;fe-pi-audio&quot;,&quot;name&quot;:&quot;Fe-Pi Audio&quot;,&quot;overlay&quot;:&quot;fe-pi-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;PCM&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;generic-dac&quot;,&quot;name&quot;:&quot;Generic I2S DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-amp&quot;,&quot;name&quot;:&quot;HiFiBerry Amp&quot;,&quot;overlay&quot;:&quot;hifiberry-amp&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Master&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-dac&quot;,&quot;name&quot;:&quot;HiFiBerry DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-dacplus&quot;,&quot;name&quot;:&quot;HiFiBerry DAC Plus&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:&quot;HiFiBerry DAC+&quot;,&quot;i2c_address&quot;:&quot;4d&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;hifiberry-digi&quot;,&quot;name&quot;:&quot;HiFiBerry Digi&quot;,&quot;overlay&quot;:&quot;hifiberry-digi&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-digi-pro&quot;,&quot;name&quot;:&quot;HiFiBerry Digi+ Pro&quot;,&quot;overlay&quot;:&quot;hifiberry-digi-pro&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;hifibox-dac&quot;,&quot;name&quot;:&quot;HiFiBox DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:[&quot;HiFiBox DAC HAT&quot;,&quot;HiFiBox DAC HAT V1&quot;,&quot;HiFiBox DAC HAT V 10&quot;],&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;iqaudio-dacplus&quot;,&quot;name&quot;:&quot;IQaudIO DAC Plus&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus,unmute_amp &quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;iqamp-unmute.sh&quot;,&quot;i2c_address&quot;:&quot;4c&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;iqaudio-digiplus&quot;,&quot;name&quot;:&quot;IQaudIO Pi-Digi+&quot;,&quot;overlay&quot;:&quot;iqaudio-digi-wm8804-audio&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;iqaudio-amp&quot;,&quot;name&quot;:&quot;IQaudIO Pi-DigiAMP+&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus,unmute_amp &quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;iqamp-unmute.sh&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;justboom-amp&quot;,&quot;name&quot;:&quot;JustBoom Amp Boards&quot;,&quot;overlay&quot;:&quot;justboom-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:[&quot;JustBoom DAC HAT&quot;,&quot;JustBoom DAC HAT v1.1&quot;],&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;justboom-dac&quot;,&quot;name&quot;:&quot;JustBoom DAC Boards&quot;,&quot;overlay&quot;:&quot;justboom-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:[&quot;JustBoom DAC HAT&quot;,&quot;JustBoom DAC HAT v1.1&quot;],&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;justboom-digi&quot;,&quot;name&quot;:&quot;JustBoom Digi Boards&quot;,&quot;overlay&quot;:&quot;justboom-digi&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:[&quot;JustBoom Digi HAT&quot;,&quot;JustBoom Digi HAT v1.1&quot;],&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;mamboberry-dac&quot;,&quot;name&quot;:&quot;Mamboberry LS DAC+&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;nanosound-dac&quot;,&quot;name&quot;:&quot;NanoSound DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;502-dac&quot;,&quot;name&quot;:&quot;PI 2 Design 502DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;502-dac-pro&quot;,&quot;name&quot;:&quot;PI 2 Design 502DAC Pro&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;503hta-hybrid&quot;,&quot;name&quot;:&quot;PI 2 Design 503HTA Hybrid Tube Amp&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;phat-beat&quot;,&quot;name&quot;:&quot;pHAT BEAT&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;phat-dac&quot;,&quot;name&quot;:&quot;pHAT DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;picade-hat&quot;,&quot;name&quot;:&quot;Picade HAT&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;,&quot;eeprom_name&quot;:[&quot;Picade HAT&quot;]}, {&quot;id&quot;:&quot;pisound&quot;,&quot;name&quot;:&quot;pisound&quot;,&quot;overlay&quot;:&quot;pisound&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;no&quot;}, {&quot;id&quot;:&quot;raspidacv3&quot;,&quot;name&quot;:&quot;RaspiDACv3&quot;,&quot;overlay&quot;:&quot;raspidac3&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;rpi-dac&quot;,&quot;name&quot;:&quot;R-PI DAC&quot;,&quot;overlay&quot;:&quot;rpi-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;soekris-dac&quot;,&quot;name&quot;:&quot;Soekris dam 1021&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;speaker-phat&quot;,&quot;name&quot;:&quot;Speaker pHAT&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;st400-dac-amp&quot;,&quot;name&quot;:&quot;ST400 Dac (PCM5122) - Amp&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;taudac&quot;,&quot;name&quot;:&quot;TauDAC - DM101&quot;,&quot;overlay&quot;:&quot;taudac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;eeprom_name&quot;:&quot;TauDAC-DM101&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;terraberry-dac2&quot;,&quot;name&quot;:&quot;Terra-Berry DAC 2&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;es90x8q2m-dac&quot;,&quot;name&quot;:&quot;Volumio ESS 9028QM&quot;,&quot;overlay&quot;:&quot;es90x8q2m-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;i2c_address&quot;:&quot;48&quot;,&quot;needsreboot&quot;:&quot;no&quot;} ]}, {&quot;name&quot;:&quot;Odroid C1+&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;odroid-hifi-shield&quot;,&quot;name&quot;:&quot;HiFi Shield&quot;,&quot;overlay&quot;:&quot;&quot;,&quot;alsanum&quot;:&quot;2&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;} ]}, {&quot;name&quot;:&quot;Sparky&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;piano-dac&quot;,&quot;name&quot;:&quot;Allo Piano&quot;,&quot;overlay&quot;:&quot;&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:[&quot;snd-soc-allo-piano-dac&quot;],&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;piano-dac-plus&quot;,&quot;name&quot;:&quot;Allo Piano 2.1&quot;,&quot;overlay&quot;:&quot;&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:[&quot;snd-soc-allo-piano-dac-plus&quot;],&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;} ]}, {&quot;name&quot;:&quot;Tinkerboard&quot;,&quot;data&quot;:[ {&quot;id&quot;:&quot;hifiberry-amp&quot;,&quot;name&quot;:&quot;HiFiBerry Amp&quot;,&quot;overlay&quot;:&quot;hifiberry-amp&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Master&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-dac&quot;,&quot;name&quot;:&quot;HiFiBerry DAC&quot;,&quot;overlay&quot;:&quot;hifiberry-dac&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;hifiberry-dacplus&quot;,&quot;name&quot;:&quot;HiFiBerry DAC Plus&quot;,&quot;overlay&quot;:&quot;hifiberry-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;&quot;,&quot;needsreboot&quot;:&quot;yes&quot;}, {&quot;id&quot;:&quot;iqaudio-dacplus&quot;,&quot;name&quot;:&quot;IQaudIO DAC Plus&quot;,&quot;overlay&quot;:&quot;iqaudio-dacplus&quot;,&quot;alsanum&quot;:&quot;1&quot;,&quot;mixer&quot;:&quot;Digital&quot;,&quot;modules&quot;:&quot;&quot;,&quot;script&quot;:&quot;iqamp-unmute.sh&quot;,&quot;needsreboot&quot;:&quot;yes&quot;} ]} ]} What you need to do Basically edit the dac.json appropriately and send us a pull request. Here's what you need to change: Add your DAC under the specific device it's for, like Raspberry PI or Odroid id: An unique identifier. Lowercase and without spaces, possibly use the dt-overlay as id. name: the name that will represent your DAC overlay: mandatory for raspberry PI. The DTOverlay parameter, used to enable the DAC. If more than one, comma separate them. alsaname: if you know how your DAC is named by alsa, its a plus to have it declared here alsanum: leave it to 1 mixer: if your DAC has an hardware mixer, indicate it here, so it will be automatically configured script: if you need a script to be launched on start, write here the name and place the script inside the scripts folder eeprom_name:for Raspberry PI only. Volumio can automatically detect your DAC and configure it without user intervention. The auto-detection method works best by reading the eeprom that every HAT should have. Specifically, we look for the content of \/proc\/device-tree\/hat\/product . So indicate here such content. Arrays are also accepted, in case this varies over time. This will look like &quot;eeprom_name&quot;:[&quot;JustBoom DAC HAT&quot;,&quot;JustBoom DAC HAT V1&quot;,&quot;JustBoom DAC HAT V 10&quot;] i2c_address: for Raspberry PI only. As a fallback, we can detect also a specific DAC via its i2c address. Indicate it here. This is a fallback mechanism in case eeprom reading won't work. IMPORTANT: Many dacs can have the same i2c address so use it only if there isn't already another dac with the same address. needs_reboot: on Raspberry PI we can enable some DACs without rebooting, by appying the DTPARAM in userspace. This doesn't work with all dacs. So please try first with this set to no. If that works and you can hear sound, fine. If that does not happen it means that your DAC is not capable of being activated without rebooting, and set this to yes.","tags":"","url":"I2S_DACs\/Adding_Compatibility_to_your_DAC.html"},{"title":"Introduction","text":"Introduction Note This is work in progress and will be updated the coming couple of days Last change: 18.06.2017\/ gkkpch What does it cover This is a guideline for porting Volumio to new ARM platforms, not a step-by-step instruction or cookbook. It covers most of the steps needed: Creating\/ compiling u-boot to make the new board image bootable Compiling a suitable kernel, the device tree, modules and firmware Creating a platform repo to support the build process Creating the board-specific image.sh script Creating the board-specific config.sh script As arm devices can differ regarding kernel version, supported u-boot version, boot parameters, and partition layout, board-specific properties have to be taken into account. Example: some board images use uEnv.txt or boot.ini to describe the boot parameters, others use a compiled boot.scr. Or, as we will see in our build example, a combination of a compiled boot.scr and a text file to override certain defined parameters. As for u-boot, some can be compiled directly from http:\/\/git.denx.de (mostly newer boards with a mainline kernel), some need additional blobs. For some boards, blobs, SPL and u-boot are written to a device in separate steps, for others an image from u-boot and spl binary must be prepared and written to the device. The purpose of this guide is to offer help in finding the information you need to cover all these different issues. Again, the guide is not a cookbook, but it will use the Asus Tinkerboard as an example from chapter 4 onwards, describing in detail how it was done for that particular device. Advice Try to find an example build procedure for another OS, a good source of information is usually the suppliers own BSP (Board Support Package) repo or forums and wiki's (e.g. the excellent Hardkernel wiki). Also our friends at http:\/\/armbian.com are doing an awesome job supporting relevant devices, not only do the offer their own ARMBIAN distribution, they are excellent at supporting their kernels up-to-date by patching whenever relevant. In case the Armbian Team does not support your device, you are probably going to have a hard time finding a better source for info. Another good source of information (also with lots of contributions from the Armbian Team), but dedicated to Allwinner SoC based devices, is http:\/\/sunxi.org Look for things like \u00e2\u0080\u009cHow to build an SD card for .....\u00e2\u0080\u009d, it makes the porting a lot easier.","tags":"","url":"Porting_Guide\/Introduction.html"},{"title":"What Is Needed To Port Successfully","text":"What is needed to port successfully In terms of skills Good linux knowhow, good shell scripting skills and the more you know or the more information you gathered about the board you are going to use the better. If it has a community forum, consider joining it. They are usually an excellent source of information, which is especially useful when you get stuck somewhere. Build environment It is highly recommended to set up your build environment on a Debian Jessie or Ubunutu 16.04 machine. A VMware or VirtualBox on Windows is also an option. Then install a virtual machine with one of these two OS. Note In case you use Ubuntu, you may need to remove $forceyes from line 989 of \/usr\/sbin\/multistrap A corresponding kernel with overlayfs and squashfs filesystems You need the sources of the kernel, preferably the one which is used with a popular image for that particular board. For Volumio 2 it has to be a kernel version 3.18 or higher because of the overlayfs filesystem. Earlier versions can be used, provided overlayfs has been backported. This has been done by the volumio team for a number of board kernels like cubox, odroids and pine64. If your kernel does not support overlayfs, consider porting it. Refer to https:\/\/github.com\/adilinden\/overlayfs-patches\/blob\/master\/README, which has patch sets for various older kernel versions. Pick the one closest to the target version, you might be lucky and get away without a scratch :) However, this is not always the case, so if the patch set does not work and throws errors, you may have to adapt the patch manually (or ask for help). A config file (xxx_defconfig) This you need for compiling the kernel, preferably one as used with one of the popular images. It is good practice to copy the defconfig to the boot directory, so you might find one there in one of the board images. The config file does not have to have all options enabled, the reason to take it from a popular image (of course with a very similar or the same kernel version) is the fact that it has a lot of normal options people need already enabled, it just saves a lot of time. The configuration is subject to optimization later, one could remove all options and drivers which nobody needs on a Volumio 2 image. But as long as the drivers are compiled as modules there is no hurry, they won't get loaded anyway when not used. When you are going to prepare the Volumio 2 image, we suggest you also copy the used defconfig to the boot folder, so people know which options you used. If your popular image does not have the config in the boot directory, there is a slight chance you might get hold of it in the running system, example for a pine64: modprobe configs cat \/proc\/config.gz | gunzip &gt; pine64_defconfig A corresponding u-boot Pre-compiled, including other related files like bootloader blobs, or the sources of the u-boot version to compile, including the config file to use. The partition layout for the boot image Mainly to find out which sectors to put the u-boot and SPL files or other blobs. A UART-Interface It is not a must, but we highly recommend to use a UART-interface with your device. It saves a lot of time and frustration being able to see the complete boot process, starting with u-boot displaying its messages. Some devices have a proprietary interface, like the uart interface Hardkernel uses for all their devices. A very popular device is the adafruit USB to TTL Serial Cable - Debug \/ Console Cable for Raspberry Pi, we also use it. You only need three wires: TX(white), RX(green) and GND(black).","tags":"","url":"Porting_Guide\/What_Is_Needed_To_Port_Successfully.html"},{"title":"Preparing The Build Environment","text":"Preparing the Build Process Necessary packages The following packages need to be installed on your build machine, you will need them sooner or later in the build process. git squashfs-tools kpartx multistrap qemu-user-static samba debootstrap parted dosfstools qemu binfmt-support lzop chrpath gawk texinfo libsdl1.2-dev whiptail diffstat cpio libssl-dev Optional qemu-utils (only needed if x86 will be built with the machine too ) Special Requirement for Rockchip on Debian jessie Jessie's u-boot tool 'mkimage' is too old to support a &quot;rksd&quot;-type image, needed for u-boot creation with Rockchip SoC's (see &quot;Compiling U-Boot&quot;). In case you build for Rockchip, you need to download a newer version, at least 2016.11+dfsg1-4, and install it over jessie's 2014.10+dfsg1-5: wget http:\/\/ftp.debian.org\/debian\/pool\/main\/u\/u-boot\/u-boot-tools_2016.11+dfsg1-4_amd64.deb dpkg -i u-boot-tools_2016.11+dfsg1-4_amd64.deb rm u-boot-tools_2016.11+dfsg1-4_amd64.deb Toolchain You need to crosscompile for arm, this means you need the proper toolchain and also take care to use the correct version. For older kernels and u-boot we used GCC-4.9.3 (Odroids, arm and aarch64), some require GCC-5, newer ones (like our build example with the Asus Tinkerboard) now require gcc-6.1 You can download the toolchain from the Linaro organisation: http:\/\/releases.linaro.org\/components\/toolchain\/gcc-linaro\/ Create a folder \/opt\/toolchains and extract the tarball in it (example with gcc-4.9.3) sudo mkdir -p \/opt\/toolchains sudo tar xvf gcc-linaro-arm-linux-gnueabihf-4.9-2014.11_linux.tar.xz -C \/opt\/toolchains\/ Add the path to PATH and set environment variables, best to add them to $HOME\/.bashrc, just add the following lines: export ARCH=arm export CROSS_COMPILE=arm-linux-gnueabihf- export PATH=\/opt\/toolchains\/gcc-linaro-4.9-2014.11-x86_64_arm-linux-gnueabihf\/bin\/:$PATH You can apply the change by logging out and in again or evaluate\u00c2\u00a0$HOME\/.bashrc\u00c2\u00a0with source command. source ~\/.bashrc Check if the toolchain works properly by checking its version, if you can find\u00c2\u00a0gcc version string\u00c2\u00a0at the end of the output, you\u00e2\u0080\u0099re OK. arm-linux-gnueabihf-gcc -v Using built-in specs \u00e2\u0080\u00a6 \u00e2\u0080\u00a6 \u00e2\u0080\u00a6 \u00e2\u0080\u00a6 gcc version 4.9.3 20141031 (prerelease) (Linaro GCC 2014.11) \u00c2\u00a0","tags":"","url":"Porting_Guide\/Preparing_The_Build_Environment.html"},{"title":"The Process","text":"The Process When Volumio was ported to odroid c1, c2, xu4, cubox-i and pine64, we did things more or less in the same order, let's do this for the Tinkerboard too: Make a platform home folder Get u-boot and related info (defconfig, offsets for placing the u-boot on disk) Get the kernel sources and corresponding config file Compile u-boot and assemble u-boot.bin Compile the kernel, this should give you the kernel (zImage or uImage), the binary device tree (dtb), modules and firmware. You do not need to set all the kernel options right yet. At this stage in the process it is more important that the first resulting image will boot. All other options can be added after the basics have been done. Make sure that you have at least overlayfs (File Systems) and squashfs (Miscellaneous Filesystems ) enabled as modules and also the kernel has support for initramfs. There is more information on how u-boot must be built in https:\/\/github.com\/rockchip-linux\/build\/blob\/debian\/mk-uboot.sh","tags":"","url":"Porting_Guide\/The_Process.html"},{"title":"The Platform Folder","text":"The Platform Folder Create the platform folder. This will be used to store all device-specific files, like kernel, boot configuration, u-boot and SPL files and anything we find during the build which is board specific goes here. This folder gets tarred in the end and moved into a separate volumio repo, described in Saving Files to the Platform Folder. We presumed the board is called tinkerboard and we have the location of the kernel and u-boot, including the config files which we will use. Assuming, Asus will released further sbc's in the future, we will name the platform folder &quot;platform_asus&quot; and create a subfolder &quot;tinkerboard&quot; which will hold the platform files for that board. Then start preparing, assuming the root of the platform files is in $HOME\/asus-build mkdir $HOME\/asus-build\/platform-asus mkdir $HOME\/asus-build\/platform-asus\/tinkerboard\/boot mkdir $HOME\/asus-build\/platform-asus\/tinkerboard\/etc mkdir $HOME\/asus-build\/platform-asus\/tinkerboard\/u-boot mkdir $HOME\/asus-build\/platform-asus\/tinkerboard\/usr Note: eventually you need to add the platform folder to the Volumio repo. This does not need to be done immediately. Chapter &quot;Creating the image&quot; shows a way to build an image before integrating the new scripts and platform files into the repo. The same method can be used to test new platform files before they are pushed. When integration is due, get in touch with @volumio (Micelangelo) to have him create the platform-file repo, in our case &quot;platform-asus&quot;. Fork this one and clone it to your host PC, add (or edit) the README.md file. This file should at least contain a reference the used kernel source location, u-boot and other relevant device-specific info. Best practise also means you keep a changelog in README.md. Examples of README.md in are in the Volumio Platform repos.","tags":"","url":"Porting_Guide\/The_Platform_Folder.html"},{"title":"Compiling U-Boot","text":"Compiling U-Boot Clone u-boot git clone git:\/\/git.denx.de\/u-boot.git u-boot -b master --depth 1 Patches At the time of writing, there is a correction\/ change for u-boot, which has not been committed to the official U-Boot repository yet. It deals with fixing an eth mac address. When volumio is configured to use dhcp for eth (which is default), the device should not get a new IP address every time the device is booted. With this patch, a fixed eth mac address is generated, using device-specific info from an EEPROM. The patch file is in folder &quot;platform-files&quot;, under &quot;patches&quot;. Copy the patch to the root of the u-boot folder and apply it like this: patch -p1 &lt; tinker_set_ethaddr_in_late_init.patch Compile There is a u-boot configuration for the Tinkerboard in the master branch, we will compile u-boot using it: cd u-boot make clean (does not do anything here as we just cloned) make tinker-rk3288_defconfig touch .scmversion (to get a clean u-boot version number) make -j8 assumption DEST=$HOME\/platform-asus\/tinkerboard Create the u-boot.img For a correct boot process, the u-boot spl and u-boot dtb are combined into a single u-boot.bin file, to be used for the Tinkerboard image build script. mkimage -n rk3288 -T rksd -d spl\/u-boot-spl-dtb.bin ..\/platform-asus\/tinkerboard\/u-boot\/u-boot.img mkdir $DEST\/u-boot (in case not yet existing) cat u-boot-dtb.bin &gt;&gt; $DEST\/u-boot\/u-boot.img The u-boot image must be copied to the beginning of the device, skip 64 blocks for the location of the loader. This should be done in the tinkerimage.sh script, to be explained later. dd if=platform-asus\/tinkerboard\/u-boot\/u-boot.img of=${LOOP_DEV} seek=64 conv=notrunc","tags":"","url":"Porting_Guide\/Compiling_U-Boot.html"},{"title":"Get The Kernel Source","text":"Getting the kernel Source Use the Asus Tinkerboard Repo to get the kernel source (4.4.xx) Luckily, Asus now supplyies their own kernel repo Start with downoading onto your Home folder git clone http:\/\/github.com\/tinkerboard\/debian_kernel linux-asus Patches Sometimes, especially with brand new boards, changes are made by others, which would suit Volumio but haven't found their way into the (vendor's) kernel repo. A way to get these into our kernel is applying these changes aspatches. At the time of writing, 3 patches are know, which I will apply from one single patch file. It deals with: Change in the kernel compile 'makefile' in order to eliminate two very strict syntax checks, which causes the compile to fail with gcc version 6. The best way would have been to fix the sources, but I consider that a task for the maintainers. Change to the behavior of two board leds, allowing one blinking as a heartbeat and the other one blinking for disk activity an entry in the usb quirks table, to show the internal usb audio device to show a friendly name (Tinkerboard) The patch is in the plaform-asus folder, under &quot;patches&quot;: Volumio-Kernel.patches. Copy it to the kernel root folder and apply as follows: patch -p1 &lt; Volumio-Kernel.patches","tags":"","url":"Porting_Guide\/Get_The_Kernel_Source.html"},{"title":"Configure Kernel Options","text":"Changing Kernel Options, Volumio requirements Basics support for initramfs overlayfs squashfs nls437 nfs server Volumio 2 reqs usb audio board's soc sound options and codes iptables all built-in wireless options (wifi\/bluetooth) and possible wifi dongles Wherever possible, configure the options as a module (no need to blow up the kernel for things we not always use)","tags":"","url":"Porting_Guide\/Configure_Kernel_Options.html"},{"title":"Compiling The Kernel","text":"Compiling the Kernel First we will rename the kernel config to something more logical. This is normally not necessary, but in this case we started when the original miniarm-rk3288 was not renamed to Tinker Board yet. cd linux-asus\/arch\/arm\/configs cp miniarm-rk3288_defconfig tinker-rockchip_defconfig We will use this renamed default kernel config Let us build the kernel step by step. Of course 'make clean' does nothing on first compile, as there is nothing to clean. Otherwise it is a good idea to start with this when options are going to be changed. After that we select the kernel config tu use and in this case we also start kernel configuration. cd $HOME\/linux-asus make clean make tinker-rockchip_defconfig make menuconfig At this stage ensure all minimum options from the previous chapter have been selected. To get a bootable, first volumio image, we need at least overlayfs, squashfs and nls437 as a module. Then save and exit menuconfig. When you want to keep the changes permanent: cp .config arch\/arm\/configs\/my_tinker-default_defconfig Or easier if you keep the same name: make savedefconfig Continue compiling the kernel make -jx (For x take 1.5 times the number of cpus you have available) This does all the work defined in the makefile, including dts compilation","tags":"","url":"Porting_Guide\/Compiling_The_Kernel.html"},{"title":"Saving Files To The Platform Folder","text":"Saving the files to the Platform Folder We are now ready to save all he files to the platform-asus folder, where they can be picked up to be used from the volumio tinker board build script. Assumptions DESTDIR=$HOME\/asus-build\/platform-asus\/tinkerboard KERNELDIR=$HOME\/linux-asus UBOOTDIR=$HOME\/u-boot u-boot Assuming you compiled u-boot from the guideline above, you already saw how the u-boot image landet in the latform folder. For the kernel we want to do a little more. It is always handy to the last few kernel configurations. It is good practise, to copy the current kernel config to the boot folder. In the boot folder should only hold the current one. Chapter 2 also showed how to save the config to the kernel. To help identify the con fig file, I like adding the kernel version to the filename, including a timestamp. kver=`make kernelrelease`-`date +%Y.%d.%m-%H.%M` rm $DESTDIR\/boot\/config* cp .config $DESTDIR\/boot\/config-${kver} cp .config $DESTDIR\/config-${kver} Kernel Next step is to save the kernel, in this case a zImage, and the dts cp arch\/arm\/boot\/zImage $DESTDIR\/boot cp arch\/arm\/boot\/dts\/*.dtb $DESTDIR\/boot\/dtb Modules and firmware For building an image, the only thing missing are the modules and firmware. Best is to delete the previous lib folder, avoiding the risk to save the ones from an older kernel version rm -r $DESTDIR\/lib make modules_install ARCH=arm INSTALL_MOD_PATH=$DESTDIR make firmware_install ARCH=arm INSTALL_FW_PATH=$DESTDIR\/lib\/firmware Patches and other files As we do not want to loose the patches, we save these as well (though we only need these once after cloning the repos. git diff &gt; $DESTDIR\/tinkerboard\/patches\/Volumio-Kernel.patches","tags":"","url":"Porting_Guide\/Saving_Files_To_The_Platform_Folder.html"},{"title":"A Complete Script","text":"Creating a complete Script for compiling U-Boot and Kernel #!\/bin\/sh DESTDIR=$HOME\/asus-build\/platform-asus\/tinkerboard KERNELDIR=$HOME\/linux-asus UBOOTDIR=$HOME\/u-boot TARDIR=\/media\/nas\/asus echo &quot;Compiling u-boot...&quot; cd $UBOOTDIR touch .scmversion make clean make tinker-rk3288_defconfig make -j8 echo &quot;Create u-boot image...&quot; mkimage -n rk3288 -T rksd -d spl\/u-boot-spl-dtb.bin $DESTDIR\/u-boot\/u-boot.img cat u-boot-dtb.bin &gt;&gt; $DESTDIR\/u-boot\/u-boot.img cd $KERNELDIR echo &quot;Cleaning kernel folder...&quot; touch .scmversion make clean echo &quot;Configuring options...&quot; make tinker-rockchip_defconfig make menuconfig cp .config.old arch\/arm\/configs\/tinker-rockchip_defconfig.old cp .config arch\/arm\/configs\/tinker-rockchip_defconfig echo &quot;Compiling the kernel...&quot; make -j12 echo &quot;Saving configuration...&quot; kver=`make kernelrelease`-`date +%Y.%d.%m-%H.%M` rm $DESTDIR\/boot\/config* cp .config $DESTDIR\/boot\/config-${kver} cp .config $DESTDIR\/config-${kver} echo &quot;Saving kernel and dtb's...&quot; cp arch\/arm\/boot\/zImage $DESTDIR\/boot cp arch\/arm\/boot\/dts\/*.dtb $DESTDIR\/boot\/dtb echo &quot;Saving modules and firmware...&quot; rm -r $DESTDIR\/lib make modules_install ARCH=arm INSTALL_MOD_PATH=$DESTDIR make firmware_install ARCH=arm INSTALL_FW_PATH=$DESTDIR\/lib\/firmware echo &quot;Saving Volumio kernel patches&quot; git diff &gt; $DESTDIR\/tinkerboard\/patches\/Volumio-Kernel.patches echo &quot;Backup platform files...&quot; cd $TARDIR tar cfvJ tinkerboard.tar.xz .\/tinkerboard echo &quot;Creating platform files completed&quot;","tags":"","url":"Porting_Guide\/A_Complete_Script.html"},{"title":"Creating the image","text":"Creating the Image Prerequisites git squashfs-tools kpartx multistrap qemu-user-static samba debootstrap parted dosfstools qemu binfmt-support qemu-utils It is recommended, not a necessity, to use Debian Jessie 8 (as that's what we are building for). If you build on Ubuntu, you may need to remove $forceyes from line 989 of \/usr\/sbin\/multistrap. You need to fork the volumio build repo from github. Work on that version until you are ready to integrate, then issue a PR. Volumio Build location: http:\/\/github.com\/volumio\/Build You will need build a rootfs for the build scripts, use Volumio's main script build.sh Do not change the main Volumio build script yet, leave build.sh and your build scripts separate until you are satisfied with the new scripts and wish to integrate. The script is self-explanatory, to integrate, add your start script just before line &quot;x86) echo 'Writing x86 Image File'&quot;. To build the rootfs: go to the root of your build folder and type: sudo .\/build.sh -b armv7 (We use armv7 here, as arm should only be used for PI and armv8 is not supported yet) Building the scripts Image building is done in two steps, implemented in two separate scripts. These scripts form a set. One script deals with image creation and calls the second one, which runs under chroot and deals with device-specific configuration. For examples of these build script sets, see the scripts folder in the Volumio Build repo. There are two &quot;types&quot; of sets: ones that add kernel and bootloader from pre-built packages during device-specific configuration. Good examples are raspberry and X86. others that add bootloader, kernel and other platform files during the image creation part. Good examples are Odroid C2 and Sparky. You need to figure out, which type suits best, then take one of those sets as a template. Most times there is no need to build completely from scratch. Main tasks of the first script (for details see chapter Image Build Part 1): creates the image &quot;bed&quot; creates the different partitions downloads the platform files installs bootloader, adds kernel, boot config, dtb(s) etc., depending on build script type, see above copies the Volumio rootfs (created separately for arm, armv7 or x86) calls the configuration script creates the squashfs (compressed) filesystem from the rootfs Main tasks of the configuration script (for details see chapter Image Bild Part 2): creates fstab installs bootloader, adds kernel, boot config, dtb(s) etc., depending on build script type, see above adds device-specific packages adds device-specific kernel modules (eg. sound and wireless drivers) finishes with building the initramfs Naming convention The scripts are usually named after the board name (or it's shortname), followed by &quot;image.sh&quot; for script one and &quot;.config.sh&quot; for the second script. In this example case: tinkerimage.sh and tinkerconfig.sh (with a shortname as we don't want the boardname too long) Warning The Tinkerboard is a brand new board, it was used as an example and still is WIP. This means a number of changes may still be necessary, which most likely will affect the config script. The image image script Building the image Once the scripts have been created, you can start testing them, go to the rootfolder of the build repo and type: sudo .\/scripts\/tinkerimage.sh -v -2.200draft For the version string you can actually use whatever suits you to identify your image. The version is only relevant for released and centrally built images.","tags":"","url":"Porting_Guide\/Creating_the_image.html"},{"title":"Creating the image build scripts (Part 1)","text":"Creating the Image Build Script (Part 1) Before we start I decided to use odroidc1image.sh as a template and copied it to tinkerimage.sh This chapter will describe which parts need to be adjusted and for what reason. For the complete template script see http:\/\/github.com\/volumio\/Build\/scripts\/odroidc1image.sh The resulting tinkerimage.sh can be found here The parts of the C1 template which are not mentioned here are considered generic and unlikely candidates for changes. Creating the image file This part is self-explanatory, the file needs the name of the new image. IMG_FILE=&quot;Volumio${VERSION}-${BUILDDATE}-odroidc1.img&quot; becomes IMG_FILE=&quot;Volumio${VERSION}-${BUILDDATE}-tinkerboard.img&quot; Partitioning The size of the file is the same for most devices (currently 2.8GB), it will get three partitions a boot partition (fat32) of approx. 60-64MB an image partition (ext4) of approx. 2.3GB a data partition (ext4) with the rest (which will get resized on first boot to the complete size of the card the image was flashed to) The boot partition's offset is the first one from the device-specific adaption and needs to be chosen carefully. It depends on the size of the bootloader(s). For the C1 and Tinkerboard the bootloaders fit into the first block, so the partitioning details remain unchanged. Preparing for the tinkerboard rockchip kernel\/ platform files This part is also self-explanatory, we only need to change the names of the platform repo and tar file. We use the name platform-asus and tinkerboard.tar.xz from the kernel build process. if [ -d platform-asus ] then echo &quot;Platform folder already exists - keeping it&quot; # if you really want to re-clone from the repo, then delete the platform-asus folder # that will refresh all the asus platforms, see below else echo &quot;Clone asus files from repo&quot; git clone https:\/\/github.com\/volumio\/platform-asus.git platform-asus echo &quot;Unpack the Tinkerboard platform files&quot; cd platform-asus tar xfJ tinkerboard.tar.xz cd .. fi This won't work yet, as we have not pushed the platform files to the volumio repo. To be able to use the script anyway, go to the root folder from your build repo copy and type mkdir platform-asus cd platform-asus cp $DESTDIR\/tinkerboard.tar.xz . (where $DESTDIR is the one you used in Chapter &quot;Saving Files to the Platform folder&quot;) tar xvfJ tinkerboard.tar.xz Copying the bootloaders This is the second device-specific adaption of the script, together with the boot partition offset, this us usually the most critical part of customizing a template. This part, when not done properly, will render the image unbootable. C1 version echo &quot;Copying the bootloader&quot; dd if=platform-odroid\/odroidc1\/uboot\/bl1.bin.hardkernel of=${LOOP_DEV} bs=1 count=442 dd if=platform-odroid\/odroidc1\/uboot\/bl1.bin.hardkernel of=${LOOP_DEV} bs=512 skip=1 seek=1 dd if=platform-odroid\/odroidc1\/uboot\/u-boot.bin of=${LOOP_DEV} seek=64 sync Tinkerboard From compiling u-boot, we already know, that there is an image (only one) we need to copy to a certain position at the beginning of the image, so the C1 part gets replaced by echo &quot;Copying the bootloader&quot; dd if=platform-asus\/tinkerboard\/u-boot\/u-boot.img of=${LOOP_DEV} seek=64 conv=notrunc sync As said, this is device-specific and not always that simple, the following is an example of the Odroid XU4 echo &quot;Copying the bootloader and trustzone software&quot; dd iflag=dsync oflag=dsync if=platform-odroid\/odroidxu4\/uboot\/bl1.bin.hardkernel of=${LOOP_DEV} seek=1 dd iflag=dsync oflag=dsync if=platform-odroid\/odroidxu4\/uboot\/bl2.bin.hardkernel of=${LOOP_DEV} seek=31 dd iflag=dsync oflag=dsync if=platform-odroid\/odroidxu4\/uboot\/u-boot.bin.hardkernel of=${LOOP_DEV} seek=63 dd iflag=dsync oflag=dsync if=platform-odroid\/odroidxu4\/uboot\/tzsw.bin.hardkernel of=${LOOP_DEV} seek=719 echo &quot;Erasing u-boot env&quot; dd iflag=dsync oflag=dsync if=\/dev\/zero of=${LOOP_DEV} seek=1231 count=32 bs=512 sync Copying system files, preparing for board configuration This part is also self-explanatory, it deals with the rootfs, kernel image, dtb, boot configuration, modules and firmware. Just ensure the files are copied to the right locations and it fits the boot configuration you created. Starting chroot Again, the part is more or less generic and easy to adapt (2 x script name and 1 x boardname) chroot \/mnt\/volumio\/rootfs \/bin\/bash -x &lt;&lt;'EOF' su - \/tinkerconfig.sh EOF #cleanup rm \/mnt\/volumio\/rootfs\/root\/init \/mnt\/volumio\/rootfs\/tinkerconfig.sh echo &quot;Unmounting Temp devices&quot; umount -l \/mnt\/volumio\/rootfs\/dev umount -l \/mnt\/volumio\/rootfs\/proc umount -l \/mnt\/volumio\/rootfs\/sys echo &quot;==&gt; Tinkerboard device installed&quot;","tags":"","url":"Porting_Guide\/Creating_the_image_build_scripts (Part 1).html"},{"title":"Creating the image build scripts (Part 2)","text":"Creating the Image Build Script (Part 2) For the config script we use the corresponding odroidc1config.sh as a template. This chapter will describe which parts need to be adjusted and for what reason. For the complete template script see http:\/\/github.com\/volumio\/Build\/scripts\/odroidc1config.sh The resulting tinkerimage.sh can be found here The parts of the C1 template which are not mentioned here are considered generic and unlikely candidates for changes. Creating fstab Just change the description in line 1. This part is standard in most implementations we encountered as most devices boot from mmcblk0, independent of SD or eMMC. That said, this may call for a future change. Newer devices using mainline u-boot and offering boot from emmc and sd are now using different devices. This may require the UUID for locating the correct boot device as we do not want to produce separate images for booting from SD or eMMC. An example implementation &quot;by_UUID&quot; you will find in the x86 build scripts. Adding default sound modules Tinkerboard does not (yet) support i2s devices, so no need to load sound modules. This may chnage in future releases. init script Tinkerboard is still headless, C1 uses a script to initialise the framebuffer at an early stage (C1-init.sh). In case Tinkerboard needs this, add it to the tinker init script, which was implemented like this: echo &quot;#!\/bin\/sh echo 2 &gt; \/proc\/irq\/45\/smp_affinity &quot; &gt; \/usr\/local\/bin\/tinker-init.sh chmod +x \/usr\/local\/bin\/tinker-init.sh echo &quot;#!\/bin\/sh -e \/usr\/local\/bin\/tinker-init.sh exit 0&quot; &gt; \/etc\/rc.local Currently, the init script changes the usb interrupt CPU affinity (from CPU0 to CPU1). This was done to avoid possible crackling and dropouts on usb audio. The script runs when rc.local is called at boot time. Additional packages lirc is installed, but no specific configuration for a remote is present yet. It defaults to a small remote Hardkernel offers for the C1\/C2. As no framebuffer initialisation is done, package &quot;fbset&quot; is not needed and removed.","tags":"","url":"Porting_Guide\/Creating_the_image_build_scripts (Part 2).html"},{"title":"Boot Parameters","text":"Boot Parameters Boot configuration depends on the u-boot version in use for the particular platform. Always look for prebuilt vendor images, they are a good source of the option(s) you have. With the u-boot version we use, there are several options to achieve boot configuration with our requirements. Below is a script we would have used with an armbian based kernel\/ u-boot, it is based on a compiled boot.scr (from boot.cmd) and an optional text file to override predefined variables. Very flexible and works with many platforms. boot.scr setenv volumioenv &quot;\/dev\/mmcblk0p1&quot; setenv fdt_file &quot;rk3288-miqi.dtb&quot; setenv ramdisk_addr_r &quot;0x21000000&quot; setenv console &quot;ttyS2,115200n8&quot; setenv verbosity &quot;1&quot; itest.b ${devnum} == 0 &amp;&amp; echo &quot;U-boot loaded from SD&quot; itest.b ${devnum} == 1 &amp;&amp; echo &quot;U-boot loaded from eMMC&quot; if load ${devtype} ${devnum}:1 ${ramdisk_addr_r} \/boot\/volumio-env.txt || load ${devtype} ${devnum}:1 ${ramdisk_addr_r} volumio-env.txt; then env import -t ${ramdisk_addr_r} ${filesize} fi setenv bootargs &quot;consoleblank=0 scandelay ${volumioenv} rw console=${console} rootfstype=ext4 loglevel=${verbosity} rootwait ${extraargs} &quot; ext4load ${devtype} ${devnum}:1 ${fdt_addr_r} \/boot\/dtb\/${fdt_file} || fatload ${devtype} ${devnum}:1 ${fdt_addr_r} dtb\/${fdt_file} || ext4load ${devtype} ${devnum}:1 ${fdt_addr_r} dtb\/${fdt_file} ext4load ${devtype} ${devnum}:1 ${ramdisk_addr_r} \/boot\/uInitrd || fatload ${devtype} ${devnum}:1 ${ramdisk_addr_r} uInitrd || ext4load ${devtype} ${devnum}:1 ${ramdisk_addr_r} uInitrd ext4load ${devtype} ${devnum}:1 ${kernel_addr_r} \/boot\/zImage || fatload ${devtype} ${devnum}:1 ${kernel_addr_r} zImage || ext4load ${devtype} ${devnum}:1 ${kernel_addr_r} zImage bootz ${kernel_addr_r} ${ramdisk_addr_r} ${fdt_addr_r} # Recompile this script with # mkimage -C none -A arm -T script -d \/boot\/boot.cmd \/boot\/boot.scr # or # Edit volumio-env.txt to override defined setenv parameters This would be the corresponding volumio-env.txt file verbosity=1 volumio=imgpart=\/dev\/mmcblk0p2 imgfile=\/volumio_current.sqsh console=tty2,ttyS2,115200n8 extlinux\/extlinux.conf As there is no requirement for flexibility and hardly anything we need to configure for Volumio, the extlinux.conf option in the boot partition is all we need. The file is located in boot\/extlinux and has the following content, adapted from one of the Asus prebuilt images: label kernel-4.4 kernel \/zImage fdt \/dtb\/rk3288-miniarm.dtb initrd \/uInitrd append earlyprintk console=tty1 console=ttyS1,115200n8 imgpart=\/dev\/mmcblk0p2 imgfile=\/volumio_current.sqsh","tags":"","url":"Porting_Guide\/Boot_Parameters.html"},{"title":"How To Build A Sparky","text":"sparky-build Scripts to help build Sparky image Prerequisites git squashfs-tools kpartx multistrap qemu-user-static samba debootstrap parted dosfstools qemu binfmt-support qemu-utils It is recommended, not a necessity, to use Debian Jessie 8 (as that's what we are building for). If on Ubuntu, you may need to remove $forceyes from line 989 of \/usr\/sbin\/multistrap How to Prepare clone the help scripts repo to $HOME : git clone http:\/\/github.com\/gkkpch\/sparky-build $HOME\/sparky-build go to $HOME\/sparky-build, type .\/infrainit.sh This will clone the sparky kernel repo to $HOME\/sparky-linux clone the official Volumio 2 build repo to $HOME\/volumio-build place the default platform-sparky files into the volumio-build folder Build the platform files go to $HOME\/sparky-build to start the kernel build, type: .\/build-kernel.sh In case you don't need kernel config changes, just exit menuconfig. Otherwise do not forget to save the config (via menu or when prompted). Build Sparky Image goto $HOME\/volumio-build and type: sudo .\/build.sh -b arm -d sparky -v -&lt;anything to identify&gt; You can do it separate, rootfs first and then the image: sudo .\/build.sh -b arm sudo .\/build.sh -d sparky -v -&lt;anything to identify&gt; Once you built the arm rootfs, there is no need to repeat this (unless volumio has changed). For subsequent image builds, just do: sudo .\/build.sh -d sparky -v -&lt;anything to identify&gt;","tags":"","url":"Building_Images_How_To\/How_To_Build_A_Sparky.html"},{"title":"Markdown Cheatsheet","text":"# H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 ====== Alt-H2 ------ H1 H2 H3 H4 H5 H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 Alt-H2 Emphasis Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. Lists (In this example, leading and trailing spaces are shown with with dots: \u00e2\u008b\u0085) 1. First ordered list item 2. Another item \u00e2\u008b\u0085\u00e2\u008b\u0085* Unordered sub-list. 1. Actual numbers don't matter, just that it's a number \u00e2\u008b\u0085\u00e2\u008b\u00851. Ordered sub-list 4. And another item. \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085To have a line break without a paragraph, you will need to use two trailing spaces.\u00e2\u008b\u0085\u00e2\u008b\u0085 \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085Note that this line is separate, but within the same paragraph.\u00e2\u008b\u0085\u00e2\u008b\u0085 \u00e2\u008b\u0085\u00e2\u008b\u0085\u00e2\u008b\u0085(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) * Unordered list can use asterisks - Or minuses + Or pluses First ordered list item Another item Unordered sub-list. Actual numbers don't matter, just that it's a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Links There are two ways to create links. [I'm an inline-style link](https:\/\/www.google.com) [I'm an inline-style link with title](https:\/\/www.google.com \"Google's Homepage\") [I'm a reference-style link][Arbitrary case-insensitive reference text] [I'm a relative reference to a repository file](..\/blob\/master\/LICENSE) [You can use numbers for reference-style link definitions][1] Or leave it empty and use the [link text itself]. URLs and URLs in angle brackets will automatically get turned into links. http:\/\/www.example.com or &lt;http:\/\/www.example.com&gt; and sometimes example.com (but not on Github, for example). Some text to show that the reference links can follow later. [arbitrary case-insensitive reference text]: https:\/\/www.mozilla.org [1]: http:\/\/slashdot.org [link text itself]: http:\/\/www.reddit.com I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself. URLs and URLs in angle brackets will automatically get turned into links. http:\/\/www.example.com or http:\/\/www.example.com and sometimes example.com (but not on Github, for example). Some text to show that the reference links can follow later. Images Here's our logo (hover to see the title text): Inline-style: ![alt text](https:\/\/github.com\/adam-p\/markdown-here\/raw\/master\/src\/common\/images\/icon48.png \"Logo Title Text 1\") Reference-style: ![alt text][logo] [logo]: https:\/\/github.com\/adam-p\/markdown-here\/raw\/master\/src\/common\/images\/icon48.png \"Logo Title Text 2\" Here's our logo (hover to see the title text): Inline-style: Reference-style: Code and Syntax Highlighting Code blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and Markdown Here -- support syntax highlighting. Which languages are supported and how those language names should be written will vary from renderer to renderer. Markdown Here supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the highlight.js demo page. Inline `code` has `back-ticks around` it. Inline code has back-ticks around it. Blocks of code are either fenced by lines with three back-ticks ```, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting. ```javascript var s = \"JavaScript syntax highlighting\"; alert(s); ``` ```python s = \"Python syntax highlighting\" print s ``` ``` No language indicated, so no syntax highlighting. But let's throw in a &lt;b&gt;tag&lt;\/b&gt;. ``` var s = \"JavaScript syntax highlighting\"; alert(s); s = \"Python syntax highlighting\" print s No language indicated, so no syntax highlighting in Markdown Here (varies on Github). But let's throw in a &lt;b&gt;tag&lt;\/b&gt;. Tables Tables aren't part of the core Markdown spec, but they are part of GFM and Markdown Here supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application. Colons can be used to align columns. | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown | Less | Pretty --- | --- | --- *Still* | `renders` | **nicely** 1 | 2 | 3 Colons can be used to align columns. Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown Less Pretty Still renders nicely 1 2 3 Blockquotes &gt; Blockquotes are very handy in email to emulate reply text. &gt; This line is part of the same quote. Quote break. &gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. Inline HTML You can also use raw HTML in your Markdown, and it'll mostly work pretty well. &lt;dl&gt; &lt;dt&gt;Definition list&lt;\/dt&gt; &lt;dd&gt;Is something people use sometimes.&lt;\/dd&gt; &lt;dt&gt;Markdown in HTML&lt;\/dt&gt; &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;\/em&gt;.&lt;\/dd&gt; &lt;\/dl&gt; Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. Horizontal Rule Three or more... --- Hyphens *** Asterisks ___ Underscores Three or more... Hyphens Asterisks Underscores Line Breaks My basic recommendation for learning how line breaks work is to experiment and discover -- hit &lt;Enter&gt; once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. \"Markdown Toggle\" is your friend. Here are some things to try out: Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a *separate paragraph*. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the *same paragraph*. Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also begins a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph. (Technical note: Markdown Here uses GFM line breaks, so there's no need to use MD's two-space line breaks.) Youtube videos They can't be added directly but you can add an image with a link to the video like this: &lt;a href=\"http:\/\/www.youtube.com\/watch?feature=player_embedded&amp;v=YOUTUBE_VIDEO_ID_HERE \" target=\"_blank\"&gt;&lt;img src=\"http:\/\/img.youtube.com\/vi\/YOUTUBE_VIDEO_ID_HERE\/0.jpg\" alt=\"IMAGE ALT TEXT HERE\" width=\"240\" height=\"180\" border=\"10\" \/&gt;&lt;\/a&gt; Or, in pure Markdown, but losing the image sizing and border: [![IMAGE ALT TEXT HERE](http:\/\/img.youtube.com\/vi\/YOUTUBE_VIDEO_ID_HERE\/0.jpg)](http:\/\/www.youtube.com\/watch?v=YOUTUBE_VIDEO_ID_HERE) Referencing a bug by #bugID in your git commit links it to the slip. For example #1.","tags":"","url":"Good_to_Knows\/Markdown_Cheatsheet.html"},{"title":"Mounting an NFS Share","text":"Adding Music from a shared folder on a Synology tested on Synology DS412 in combination with Volumio 0.978 for Raspberry Pi 3 Since both Synology and Volumio for Raspberry PI are Unix based the preference is to use NFS type file sharing. For more information visit: https:\/\/en.wikipedia.org\/wiki\/Network_File_System Synology preparation To enable NFS on Synology follow the detailed guide from Synology [https:\/\/www.synology.com\/en-global\/knowledgebase\/DSM\/tutorial\/File_Sharing\/How_to_access_files_on_Synology_NAS_within_the_local_network_NFS] The guide will explain in great detail the steps required. The final NFS rule configuration is shown in the screenshot. The most important part is the Squash setting. The required access is RW and since it's wise to disable the Guest account on your Synology, the Squash setting must be set to Map all users to admin. Volumio preparation Go to settings &gt; My Music Add New Drive Make sure you configure the share as shown in the screenshot. volume1 is normally the first part of the path, followed by the name of your share. In this case Music Since we shared using NFS no username and password is required and","tags":"","url":"Good_to_Knows\/Mounting_an_NFS_Share.html"},{"title":"Contribute to this Doc","text":"Everyone knows how tedious it is to write documentation. But it is extremely important for every project, especially for Volumio. So if you find something incomplete, missing or wrong feel free to edit this doc and improve it. If you don't feel like editing this doc yourself, you can at least tell us what you would change here! How this doc works This DOC is powered by DAUX.IO and the source is hosted on the Github Volumio docs repository. To edit it, simply clone it, edit the pages located under \/docs and issue a pull request. You can do so either via command line or with a graphical tool, I personally suggest \u00c2\u00a0GitKraken. Cloning and issuing a Pull request Clone it https:\/\/github.com\/volumio\/docs.git Edit it I suggest Atom.io IDE together with Markdown Preview but any text editor will do Make sure you comply with DAUX rules (if you create a new page, don't use spaces but _ and make sure the name ends with .md) This doc is written in Markdown language, and automatically converted to html. See the Markdown Cheatsheet to get used to it Commit it git commit -m &quot;Hey I changed this and that&quot; Issue a pull request Once your PR gets accepted, in 2 minutes your contribution will be available to the whole community. See changes live To see your changes live, just download and launch any XAMMP environment to expose a php-capable local web server, and clone the docs under your htdocs folder. Docs will update in realtime and will be available under http:\/\/localhost\/docs","tags":"","url":"Good_to_Knows\/Contribute_to_this_Doc.html"},{"title":"Connection Outside LAN","text":"Sometimes it might be useful to connect to Volumio from outside the LAN, via services like NO-IP. Volumio UI uses socket.io to communicate with the backend, so we must tell the UI to connect to the external IP rather than the LAN's IP. Tell the UI to bind to new IP If you want to achieve this, hardcode your public IP in [https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/http\/restapi.js](https:\/\/github.com\/volumio\/Volumio2\/blob\/master\/http\/restapi.js line 49 res.json({ host: 'http:\/\/'+self.host}); your public ip instead of self.host","tags":"","url":"Good_to_Knows\/Connection_Outside_LAN.html"},{"title":"General","text":"General What is Volumio? Volumio is a free and Open Source Linux Distribution, which runs on a variety of devices, typically small and cheap computers like the Raspberry Pi, but also on low power PCs, notebooks or thin clients. It is designed and finely-tuned exclusively for bit-perfect music playback, transforming your device into a headless Audiophile Music Player, that is controlled via your mobile phone, computer or tablet. What devices are supported? There are recent images available for the Raspberry Pi (all variants : Raspberry Pi 3 Model B, Raspberry Pi 3 Model B+, Raspberry Pi Zero, Raspberry Pi Zero W.), x86\/x64 (PC\/MAC), Odroid C1\/C2, Allo Sparky, Asus Tinkerboard. In the community portings page of the forum, you'll find image for other devices : Pine64, Rock64, Sopine and other system : Community portings on the forum What are the device RAM (memory) requirements for Volumio? Volumio will work much more smoothly and quickly in devices with more RAM. The recommended mimimum is 1GB, but people are running devices with less. How do I enable ssh? ssh is disabled by default, except on the first boot, for security reasons. It is a simple procedure to enable it if required. What is a plugin? The concept of a plugin is to expand the functionality of Volumio in a particular way, for example backup of data files. Most of these are written by the Volumio Community, and can be installed from the 'Plugins' section of the Volumio UI. Officially approved plugins may be installed directly from within the UI, whereas others are required to be downloaded as a zip file first. For more details, have look here : Plugins System Overview There is a list of the currently available plugins here. Is there an app for Volumio? Many people like to control Volumio simply from a browser, but there are dedicated apps available from both Apple's App Store &amp; Google Play. Indeed, the official Volumio android app is one way of showing your support for Volumio. What files format can be read ? Volumio uses mpd and other players. Mpd is compiled in order to read following files : Readable formats: [mad] mp3 mp2 [mpg123] mp3 [vorbis] ogg oga [oggflac] ogg oga [flac] flac [opus] opus ogg oga [sndfile] wav aiff aif au snd paf iff svx sf voc w64 pvf xi htk caf sd2 [audiofile] wav au aiff aif [dsdiff] dff [dsf] dsf [faad] aac [mpcdec] mpc [wavpack] wv [modplug] 669 amf ams dbm dfm dsm far it med mdl mod mtm mt2 okt s3m stm ult umx xm [ffmpeg] 16sv 3g2 3gp 4xm 8svx aa3 aac ac3 afc aif aifc aiff al alaw amr anim apc ape asf atrac au aud avi avm2 avs bap bfi c93 cak cin cmv cpk daud dct divx dts dv dvd dxa eac3 film flac flc fli fll flx flv g726 gsm gxf iss m1v m2v m2t m2ts m4a m4b m4v mad mj2 mjpeg mjpg mka mkv mlp mm mmf mov mp+ mp1 mp2 mp3 mp4 mpc mpeg mpg mpga mpp mpu mve mvi mxf nc nsv nut nuv oga ogm ogv ogx oma ogg omg opus psp pva qcp qt r3d ra ram rl2 rm rmvb roq rpl rvc shn smk snd sol son spx str swf tak tgi tgq tgv thp ts tsp tta xa xvid uv uv2 vb vid vob voc vp6 vmd wav webm wma wmv wsaud wsvga wv wve [gme] ay gbs gym hes kss nsf nsfe sap spc vgm vgz [pcm] Web Radios Volumio can play web radio. Airplay Volumio can read Airplay streams using shairport-sync-reader Upnp Volumio can read Upnp stream More readable files With use of plugins, Volumio can read miscellanious streaming services Spotify (from webUI or Spotify connect) Youtube streams Qobuz (using MyVolumio) Tidal (using MyVolumio) Not available yet Other to come","tags":"","url":"FAQs\/General.html"},{"title":"Installation","text":"Installation How do I install Volumio? Follow the guide here (scroll down) Important If you use Windows to write your SD card, it will probably ask you to format the SD card at the end of the writing. DO NOT FORMAT THE SD CARD NOW! IT WILL ERASE WHAT YOU HAVE DONE JUST BEFORE Just eject your SD card and insert it in your device! Why is it important to leave my device alone for 6 minutes (longer on low powered devices such as the RPi Zero) on it's first boot? Volumio's first boot takes much longer than normal as it carries out a number of essential operations. These include extending the filesystem to completely fill the SD card\/hard drive, regenerate unique SSH keys for your device, install some packages, configure the system, &amp; generate new thumbnails for the default backgrounds. I don't see the Volumio UI, but a login request, what should I do? Volumio is designed to run headerless; that is to say that there is no graphical UI on the Volumio device itself. Access the Volumio UI from a browser on some other device (mobile, tablet etc.). How do I set up the wired network settings for Volumio? If your device is connected to your home network by an ethernet cable, then it should be automatically assigned an IP address by your router. You should be able to see this address from your router UI, and you can access the Volumio UI by entering the IP address in a browser on your mobile, laptop etc. For Apple and Windows computers running the 'Bonjour' service, and Linux computers running 'Avahi'\/'zeroconf' then simply entering 'http:\/\/volumio.local' will bring up the Volumio UI. Generally speaking for Android devices you will need to enter the actual IP address, although some apps will work without you needing to know this. It is desirable to have a single known (static) IP address for your device if 'volumio.local' does not work. This can either be set from your router UI, or from Volumio's 'Network Settings.' Do not directly edit system configuration files ('\/etc\/network\/interfaces') as is frequently suggested on the internet, as this method is now deprecated, and will cause problems with your device. How do I set up wireless network settings for Volumio? If your device is not connected to a wired network, then Volumio will automatically start it's own network (Hotspot) called 'Volumio' and assign an IP address of '192.168.211.1' to your device. You can log onto this network with the default password of 'volumio2', and then setup your wireless settings as you like from 'Network Settings.' After configuration, the hotspot will switch off, and your device should connect to your wireless network. The hotspot will be restarted if Volumio is unable to find your network.","tags":"","url":"FAQs\/Installation.html"},{"title":"Updating and Maintenance","text":"Updating &amp; Maintenance How do I update Volumio? Volumio features an OTA (Over The Air) updater, meant to allow a seamless and reliable way to update to new system versions. Please note that if you enable updating to intermediate beta\/test versions, you risk making your system unreliable, and may need to carry out a 'factory reset' to the last stable version that you installed. Caution: do not try to update your system by using 'sudo apt-get upgrade' ... this is likely to result in a non-functional system. How do I do a 'factory reset?' System settings may be returned to the first version that you installed by carrying out a 'factory reset' under 'System Settings.' Note that you will lose all of your settings by applying this option. How can I backup my settings? It is a good idea to have a backup of your settings (NAS, playlists, webradios etc.) and this is easily achieved by use of the 'Backup and Restore' plugin.","tags":"","url":"FAQs\/Updating_and_Maintenance.html"},{"title":"Audio Sources","text":"Audio Sources What audio sources can I add to Volumio? NAS drive shares (CIFS &amp; NFS) are easily mounted and scanned by Volumio for audio content. You can add USB hard drives, USB sticks, and use the free space on your SD card for extra or mobile storage. There are lots of built-in internet web radio streams available, and you can also add your own. Spotify and Youtube are available as plugins. Streaming from mobile devices is provided out-of-the-box by Airplay &amp; UPnP\/DLNA. How do I add a NAS drive share? Navigate to 'Settings' (&quot;cog&quot; icon at the top right), 'My Music' and click on 'Add new drive.' Volumio will attempt to automatically find any music shares, and settings can be added manually if this is not successful. You will need to choose a name for the share, and decide between CIFS (default) or NFS protocols (see your NAS GUI for more information). If entering details manually, you will also need to know the IP address of the NAS, and the path to the share (again see NAS GUI). Please ensure that the permissions on the NAS files are set correctly for CIFS in order for Volumio to be able to access them. In the case of NFS, file permissions are not so important, BUT you must allow access to the NAS from the IP address of your Volumio device (set in NAS GUI). I'm getting an error adding a CIFS network drive on my NAS Some users are experiencing problems adding shares from Synology and other NAS manufacturers in recent versions of Volumio. The current fix is to add a vers=2.0 entry to the &quot;Options&quot; field under the Network Drive's Advanced Options. Depending on the configuration of your NAS, you may require vers=1.0 or vers=3.0. vers=2.0 seems to be a well-accepted default. Does Volumio support Airplay &amp; UPnP\/DLNA? Yes, these are enabled by default, and Volumio will act as a renderer for such streams. Does Volumio support Bluetooth? No, Volumio does not natively support bluetooth, but there are considerable efforts being made by the Community to develop plugins that allow this functionaility. Is there a maximum number of tracks allowed in the music library? There isn't a maximum number of tracks, but do be aware that indexing of very large collections (&gt;10000) may take some time, especially on lower powered devices. Can I use the unused space of my SD card for music? Yes, free space on the SD card is available as a Samba share &quot;Internal Storage&quot;, which can by used as you like. Music files transferred there then they will be shown in your Volumio music library in a folder called 'INTERNAL.'","tags":"","url":"FAQs\/Audio_Sources.html"},{"title":"Audio Output","text":"Audio Output How do I set the audio output from Volumio? Select 'Settings', 'Playback Options', and choose your 'Output Device' from the drop down menu. If you are are NOT using an i2s device (for example a USB DAC), then ensure that the 'i2s' switch is in the 'Off' position. Choose the correct DAC model (note that some DAC models use a common driver), and save your settings. Reboot &amp; check that the settings are retained. Why can't I control the volume from the Volumio UI? Not all DACs include a hardware volume control (check with your device manufacturer) which allows the changing of volume from the UI. This behaviour can be achieved in such devices by selecting the Mixer Type as 'Software', rather than 'Hardware', BUT please note that this results in a degradation of the sound quality. If this is a problem then select Mixer Type as 'None', and adjust the volume on your amplifier. Does Volumio support multiroom play? Volumio does allow the control of devices in different rooms from a single Volumio UI (if you have more than one device, then they will be visible in the UI). Multiroom synchronised play is also possible through the use of a 'Snapcast' plugin.","tags":"","url":"FAQs\/Audio_Output.html"}]}